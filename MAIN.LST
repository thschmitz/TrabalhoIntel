Microsoft (R) Macro Assembler Version 6.11		    12/27/24 01:05:12
main.asm						     Page 1 - 1


				
				;
				;====================================================================
				;	- Escrever um programa para ler um arquivo texto e 
				;		apresentá-lo na tela
				;	- O usuário devem informar o nome do arquivo, 
				;		assim que for apresentada a mensagem: Nome do arquivo: 
				;====================================================================
				;
					.model		small
					.stack
						
 = 000D				CR		equ		0dh
 = 000A				LF		equ		0ah
				
 0000					.data
				
 0000 0000			ContadorBuffer  dw 	0
 0002 54 65 73 74 65 00		NomeTesteAleatorio db 	"Teste", 0
 0008 49 4E 2E 74 78 74		FileNameSrc		db		"IN.txt", 0		; Nome do arquivo a ser lido
       00
 000F 4F 55 54 2E 74 78		FileNameDst		db		"OUT.txt", 0	; Nome do arquivo a ser escrito
       74 00
 0017 0000			FileHandleSrc	dw		0				; Handler do arquivo origem
 0019 0000			FileHandleDst	dw		0				; Handler do arquivo destino
 001B  07D0 [			FileBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 07EB  07D0 [			NewBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 0FBB  07D0 [			OutputBuffer    db 		2000 dup(?) 	; Espaço para os BarCodes (64 bytes)
        00
       ]
				
				
 178B 2B			BarCodeTable DB 101011b     ; 0
 178C  6B				DB 1101011b    ; 1
 178D  4B				DB 1001011b    ; 2
 178E  65				DB 1100101b    ; 3
 178F  5B				DB 1011011b    ; 4
 1790  6D				DB 1101101b    ; 5
 1791  4D				DB 1001101b    ; 6
 1792  53				DB 1010011b    ; 7
 1793  69				DB 1101001b    ; 8
 1794  6D				DB 1101101b    ; 9
 1795  2D				DB 101101b     ; -
 1796  59				DB 1011001b    ; SS
				
				
				
 1797 45 72 72 6F 3A 20		MsgErroOpenFile		db	"Erro: Nao foi possivel fazer a abertura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 61 62 65 72 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 17CD 45 72 72 6F 3A 20		MsgErroCreateFile	db	"Erro: Nao foi possivel fazer a criacao do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 63 72 69 61 63
       61 6F 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 1802 45 72 72 6F 3A 20		MsgErroReadFile		db	"Erro: Nao foi possível fazer a leitura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       C3 AD 76 65 6C 20
       66 61 7A 65 72 20
       61 20 6C 65 69 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 1838 45 72 72 6F 3A 20		MsgErroSemStart		db	"Erro: Nao foi encontrado a palavra 'START' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 41 52 54 27
       20 6E 6F 20 61 72
       71 75 69 76 6F 2E
       0D 0A 00
 1871 45 72 72 6F 3A 20		MsgErroSemStop		db	"Erro: Nao foi encontrado a palavra 'STOP' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 4F 50 27 20
       6E 6F 20 61 72 71
       75 69 76 6F 2E 0D
       0A 00
 18A9 45 72 72 6F 3A 20		MsgErroWriteFile	db	"Erro: Nao foi possivel fazer a escrita do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 65 73 63 72 69
       74 61 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 18DE 45 72 72 6F 3A 20		MsgErrorCaracterInvalido db "Erro: Nao foi possivel fazer a traducao de um caracter que eh invalido.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 74 72 61 64 75
       63 61 6F 20 64 65
       20 75 6D 20 63 61
       72 61 63 74 65 72
       20 71 75 65 20 65
       68 20 69 6E 76 61
       6C 69 64 6F 2E 0D
       0A 00
				
 0000					.code
					.startup
				
 0017  8D 16 0008 R			lea		dx,FileNameSrc
 001B  E8 0097				call	fopen
 001E  89 1E 0017 R			mov		FileHandleSrc,bx
 0022  73 2C				jnc		Continua2
 0024  8D 1E 1797 R			lea		bx, MsgErroOpenFile
 0028  E8 021F				call	printf_s
					.exit	1
 0030				Continua1:
				
 0030  8D 16 000F R			lea		dx,FileNameDst
 0034  E8 0087				call	fcreate
 0037  89 1E 0019 R			mov		FileHandleDst,bx
 003B  73 13				jnc		Continua2
 003D  8B 1E 0017 R			mov		bx,FileHandleSrc
 0041  E8 0084				call	fclose
 0044  8D 1E 17CD R			lea		bx, MsgErroCreateFile
 0048  E8 01FF				call	printf_s
					.exit	1
 0050				Continua2:
				
 0050  8B 1E 0017 R			mov		bx,FileHandleSrc    
 0054  E8 0076				call	getChar
 0057  73 1A				jnc		Continua3
 0059  8D 1E 1802 R			lea		bx, MsgErroReadFile
 005D  E8 01EA				call	printf_s
 0060  8B 1E 0017 R			mov		bx,FileHandleSrc
 0064  E8 0061				call	fclose
 0067  8B 1E 0019 R			mov		bx,FileHandleDst
 006B  E8 005A				call	fclose
					.exit	1
 0073				Continua3:
				
 0073  83 F8 00				cmp		ax,0
 0076  74 0B				jz		TerminouArquivo
 0078  EB D6				jmp 	Continua2
 007A				Continua4:
				
 007A  8B 1E 0019 R			mov		bx,FileHandleDst
 007E  E8 01B9				call	setChar
 0081  73 CD				jnc		Continua2
					
 0083				TerminouArquivo:
				
 0083  E8 005E				call    criaNovoBuffer
				
 0086  8D 36 0FBB R			lea 	si, OutputBuffer
 008A  8D 1E 07EB R			lea 	bx, NewBuffer
 008E				loop_transformacoes:
 008E  E8 00E5				call    transformaEmBarcode
					;inc 	si
 0091  C7 04 000A			mov 	[si], 10
 0095  46				inc 	si
 0096  80 3F 00				cmp 	byte ptr [bx], 0
 0099  75 F3				jne 	loop_transformacoes
				
					
				
				
					
				
				
 009B  8D 1E 0FBB R			lea 	bx, OutputBuffer
 009F  E8 01A8				call 	printf_s
				
				
				
 00A2  8B 1E 0017 R			mov		bx,FileHandleSrc	; Fecha arquivo origem
 00A6  E8 001F				call	fclose
 00A9  8B 1E 0019 R			mov		bx,FileHandleDst	; Fecha arquivo destino
 00AD  E8 0018				call	fclose
					.exit	0
				
				
				;--------------------------------------------------------------------
				;Função	Abre o arquivo cujo nome está no string apontado por DX
				;		boolean fopen(char *FileName -> DX)
				;Entra: DX -> ponteiro para o string com o nome do arquivo
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00B5				fopen	proc	near
 00B5  B0 00				mov		al,0
 00B7  B4 3D				mov		ah,3dh
 00B9  CD 21				int		21h
 00BB  8B D8				mov		bx,ax
 00BD  C3				ret
 00BE				fopen	endp
				
				;--------------------------------------------------------------------
				;Função Cria o arquivo cujo nome está no string apontado por DX
				;		boolean fcreate(char *FileName -> DX)
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00BE				fcreate	proc	near
 00BE  B9 0000				mov		cx,0
 00C1  B4 3C				mov		ah,3ch
 00C3  CD 21				int		21h
 00C5  8B D8				mov		bx,ax
 00C7  C3				ret
 00C8				fcreate	endp
				
				;--------------------------------------------------------------------
				;Entra:	BX -> file handle
				;Sai:	CF -> "0" se OK
				;--------------------------------------------------------------------
 00C8				fclose	proc	near
 00C8  B4 3E				mov		ah,3eh
 00CA  CD 21				int		21h
 00CC  C3				ret
 00CD				fclose	endp
				
				;--------------------------------------------------------------------
				;Função	Le um caractere do arquivo identificado pelo HANLDE BX
				;		getChar(handle->BX)
				;Entra: BX -> file handle
				;Sai:   
				;		AX -> numero de caracteres lidos
				;		CF -> "0" se leitura ok
				;--------------------------------------------------------------------
 00CD				getChar proc near
 00CD  B9 0001			    mov     cx, 1                  ; Number of bytes to read
 00D0  8D 36 001B R		    lea     si, FileBuffer         ; Load the base address of FileBuffer into SI
 00D4  8B D6			    mov     dx, si                 ; Copy base address to DX (used by DOS)
 00D6  A1 0000 R		    mov     ax, ContadorBuffer     ; Load FileCounter into AX
 00D9  03 D0			    add     dx, ax                 ; Adjust DX to point to the current position
 00DB  B4 3F			    mov     ah, 3Fh                ; DOS function: Read from file
 00DD  CD 21			    int     21h                    ; Call DOS interrupt
 00DF  FF 06 0000 R		    inc     ContadorBuffer         ; Increment the counter for the next read
 00E3  C3			    ret                            ; Return to the caller
 00E4				getChar endp
				
				;--------------------------------------------------------------------
				;Função que cria um novo buffer com o conteudo do arquivo que interessa
				;		
				;Sai:   
				;		NovoBuffer -> buffer com o conteudo do arquivo
				;--------------------------------------------------------------------
 00E4				criaNovoBuffer    proc near
 00E4  8D 1E 001B R			lea bx, FileBuffer
				
 00E8				criaNovoBuffer_loop:
 00E8  8A 17				mov 	dl, [bx]	; Carrega o primeiro caractere do buffer
					
 00EA  80 FA 00				cmp 	dl, 0		; Verifica se o buffer está vazio
 00ED  74 66				je 		criaNovoBuffer_sem_start	; Se estiver, retorna
				
 00EF  80 FA 53				cmp     byte ptr dl, 'S'             ; Verifica se o caractere é 'S'
 00F2  75 5E				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 00F4  8A 57 01				mov dl, [bx + 1]
				
 00F7  80 FA 54				cmp     byte ptr dl, 'T'  ; Verifica se o próximo caractere é 'T'
 00FA  75 56				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 00FC  8A 57 02				mov dl, [bx + 2]
				
 00FF  80 FA 41				cmp     byte ptr dl, 'A'; Verifica se o próximo caractere é 'A'
 0102  75 4E				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 0104  8A 57 03				mov dl, [bx + 3]
				
 0107  80 FA 52				cmp     byte ptr dl, 'R'; Verifica se o próximo caractere é 'R'
 010A  75 46				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 010C  8A 57 04				mov dl, [bx + 4]
				
 010F  80 FA 54				cmp     byte ptr dl, 'T'; Verifica se o próximo caractere é 'T'
 0112  75 3E				jne     criaNovoBuffer_end    ; Se não for, sai do loop
 0114  83 C3 04				add     bx, 4
 0117  8D 36 07EB R			lea 	si, NewBuffer
				
 011B				criaNovoBuffer_loop2:
 011B  43				inc bx
 011C  8A 17				mov 	dl, [bx]
					;cmp     byte ptr dl, 0Ah ; CR (Carriage Return)
					;je criaNovoBuffer_loop2
					;cmp     byte ptr dl, 0Dh ; LF (Line Feed)
					;je criaNovoBuffer_loop2
				
					;dec bx
 011E				criaNovoBuffer_insere:
 011E  03 C6				add     ax, si
 0120  43				inc 	bx
 0121  8A 17				mov 	dl, [bx]
 0123  80 FA 00				cmp     byte ptr dl, 0 
 0126  74 43				je		criaNovoBuffer_sem_stop
				
 0128  88 14				mov 	byte ptr [si], dl
 012A  46				inc 	si
				
 012B  80 FA 53				cmp 	byte ptr dl, 'S' ; Verifica se o próximo caractere é 'S' de 'STOP'
 012E  75 EE				jne		criaNovoBuffer_insere
 0130  4E				dec si 
				
 0131  8A 57 01				mov 	dl, [bx + 1]
 0134  80 FA 54				cmp 	byte ptr dl, 'T' ; Verifica se o próximo caractere é 'T' de 'STOP'
 0137  75 E5				jne		criaNovoBuffer_insere
 0139  8A 57 02				mov 	dl, [bx + 2]
 013C  80 FA 4F				cmp 	byte ptr dl, 'O' ; Verifica se o próximo caractere é 'O' de 'STOP'
 013F  75 DD				jne		criaNovoBuffer_insere
 0141  8A 57 03				mov 	dl, [bx + 3]
 0144  80 FA 50				cmp 	byte ptr dl, 'P' ; Verifica se o próximo caractere é 'P' de 'STOP'
 0147  75 D5				jne		criaNovoBuffer_insere
 0149  83 C3 04				add 	bx, 4
				
 014C  C7 04 0000			mov     [si], 0
					
 0150  EB 11				jmp     criaNovoBuffer_print
					
 0152				criaNovoBuffer_end:
 0152  43				inc bx
 0153  EB 93				jmp criaNovoBuffer_loop
				
 0155				criaNovoBuffer_sem_start:
 0155  83 F9 00				cmp cx, 0
 0158  8D 1E 1838 R			lea bx, MsgErroSemStart
 015C  E8 00EB				call printf_s
					.exit
				
 0163				criaNovoBuffer_print:
 0163  8D 1E 07EB R			lea bx, NewBuffer
				
 0167  E8 00E0				call printf_s
 016A  C3				ret
				
 016B				criaNovoBuffer_sem_stop:
 016B  8D 1E 1871 R			lea bx, MsgErroSemStop
 016F  E8 00D8				call printf_s
					.exit
				
 0176				criaNovoBuffer    endp
				
				;--------------------------------------------------------------------
				;Função que traduz cada caracter do novo buffer em um barcode 
				;		
				;Sai:   
				;		Buffer com dados em barcode
				;--------------------------------------------------------------------
 0176				transformaEmBarcode proc near
 0176  B9 0000				mov     cx, 0
				
					
 0179  B9 000B				mov      cx, 11
 017C  E8 0086				call     transforma_em_barcode_exec
				
 017F				transformaEmBarcode_loop:
 017F  8A 17				mov     dl, [bx]
				
 0181  43				inc bx
				
 0182  80 FA 00				cmp     byte ptr dl, 0    ; Verifica se o buffer está vazio
 0185  75 03 E9 00A9			je      transformaEmBarcode_fim_traducao    ; Se estiver, retorna
				
 018A  80 FA 0D				cmp 	byte ptr dl, 13
 018D  75 03 E9 00A1			je 		transformaEmBarcode_fim_traducao
				
 0192  80 FA 0A				cmp 	byte ptr dl, 10
 0195  75 03 E9 0099			je 		transformaEmBarcode_fim_traducao
				
 019A  B9 0000				mov 	cx, 0
 019D  80 FA 30				cmp     byte ptr dl, '0'    ; Verifica se o caractere é '0'
 01A0  74 5D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01A2  B9 0001				mov 	cx, 1
 01A5  80 FA 31				cmp     byte ptr dl, '1'    ; Verifica se o caractere é '1'
 01A8  74 55				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01AA  B9 0002				mov 	cx, 2
 01AD  80 FA 32				cmp     byte ptr dl, '2'    ; Verifica se o caractere é '2'
 01B0  74 4D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01B2  B9 0003				mov 	cx, 3
 01B5  80 FA 33				cmp     byte ptr dl, '3'    ; Verifica se o caractere é '3'
 01B8  74 45				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01BA  B9 0004				mov 	cx, 4
 01BD  80 FA 34				cmp     byte ptr dl, '4'    ; Verifica se o caractere é '4'
 01C0  74 3D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01C2  B9 0005				mov 	cx, 5
 01C5  80 FA 35				cmp     byte ptr dl, '5'    ; Verifica se o caractere é '5'
 01C8  74 35				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01CA  B9 0006				mov 	cx, 6
 01CD  80 FA 36				cmp     byte ptr dl, '6'    ; Verifica se o caractere é '6'
 01D0  74 2D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01D2  B9 0007				mov 	cx, 7
 01D5  80 FA 37				cmp     byte ptr dl, '7'    ; Verifica se o caractere é '7'
 01D8  74 25				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01DA  B9 0008				mov 	cx, 8
 01DD  80 FA 38				cmp     byte ptr dl, '8'    ; Verifica se o caractere é '8'
 01E0  74 1D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01E2  B9 0009				mov 	cx, 9
 01E5  80 FA 39				cmp     byte ptr dl, '9'    ; Verifica se o caractere é '9'
 01E8  74 15				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01EA  B9 000A				mov 	cx, 10
 01ED  80 FA 2D				cmp     byte ptr dl, '-'    ; Verifica se o caractere é '-'
 01F0  74 0D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01F2  EB 00				jmp     transformaEmBarcode_erro_caractere_invalido
				
 01F4				transformaEmBarcode_erro_caractere_invalido:
 01F4  8D 1E 18DE R			lea     bx, MsgErrorCaracterInvalido
 01F8  E8 004F				call    printf_s
					.exit
				
 01FF				transformaEmBarcode_codigo:
 01FF  E8 0003				call transforma_em_barcode_exec
 0202  E9 FF7A				jmp transformaEmBarcode_loop
				
 0205				transforma_em_barcode_exec:
 0205  53				push 	bx
 0206  8D 1E 178B R			lea 	bx, BarCodeTable
 020A  03 D9				add 	bx, cx
 020C  8A 17				mov 	dl, [bx]
					
 020E				loop_acha_primeiro_0:
 020E  D0 E2				shl	 dl, 1
 0210  72 02				jc loop_coloca_valores_0
 0212  EB FA				jmp loop_acha_primeiro_0
				
 0214				loop_coloca_valores_0:
 0214  B8 0030				mov  ax, 30h
 0217  83 D0 00				adc  ax, 0
				
 021A  89 04				mov	 [si], ax
 021C  41				inc cx
 021D  46				inc si
				
 021E  80 FA 00				cmp 	dl, 0
 0221  74 04				je  	loop_coloca_valores_0_acaba
				
 0223  D0 E2				shl 	dl, 1
 0225  EB ED				jmp 	loop_coloca_valores_0
				
 0227				loop_coloca_valores_0_acaba:
					
 0227  83 F9 0A				cmp 	cx, 10
 022A  7F 05				jg 		loop_coloca_valores_0_acaba_final
				
 022C  C7 04 0030			mov 	[si], '0'
 0230  46				inc 	si
 0231				loop_coloca_valores_0_acaba_final:
 0231  5B				pop 	bx
 0232  C3				ret
				
 0233				transformaEmBarcode_fim_traducao:
 0233  B9 000B				mov      cx, 11
 0236  E8 FFCC				call transforma_em_barcode_exec
				
 0239  C3			    ret
				
				
 023A				transformaEmBarcode endp
				
				;--------------------------------------------------------------------
				;Entra: BX -> file handle
				;       dl -> caractere
				;Sai:   AX -> numero de caracteres escritos
				;		CF -> "0" se escrita ok
				;--------------------------------------------------------------------
 023A				setChar	proc	near
 023A  B4 40				mov		ah,40h
 023C  B9 0001				mov		cx,1
 023F  88 16 001B R			mov		FileBuffer,dl
 0243  8D 16 001B R			lea		dx,FileBuffer
 0247  CD 21				int		21h
 0249  C3				ret
 024A				setChar	endp	
				
				
				;--------------------------------------------------------------------
				;Função Escrever um string na tela
				;		printf_s(char *s -> BX)
				;--------------------------------------------------------------------
 024A				printf_s	proc	near
 024A  8A 17				mov		dl,[bx]
 024C  80 FA 00				cmp		dl,0
 024F  74 09				je		ps_1
				
 0251  53				push	bx
 0252  B4 02				mov		ah,2
 0254  CD 21				int		21H
 0256  5B				pop		bx
				
 0257  43				inc		bx		
 0258  EB F0				jmp		printf_s
				
 025A				ps_1:
 025A  C3				ret
 025B				printf_s	endp
				
				;--------------------------------------------------------------------
						end
				;--------------------------------------------------------------------
				
				
					
				
				

Microsoft (R) Macro Assembler Version 6.11		    12/27/24 01:05:12
main.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 1928	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 025B	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

criaNovoBuffer . . . . . . . . .	P Near	 00E4	  _TEXT	Length= 0113 Private
fclose . . . . . . . . . . . . .	P Near	 00C8	  _TEXT	Length= 0005 Private
fcreate  . . . . . . . . . . . .	P Near	 00BE	  _TEXT	Length= 000A Private
fopen  . . . . . . . . . . . . .	P Near	 00B5	  _TEXT	Length= 0009 Private
getChar  . . . . . . . . . . . .	P Near	 00CD	  _TEXT	Length= 0017 Private
printf_s . . . . . . . . . . . .	P Near	 024A	  _TEXT	Length= 0011 Private
setChar  . . . . . . . . . . . .	P Near	 023A	  _TEXT	Length= 0010 Private
transformaEmBarcode  . . . . . .	P Near	 0176	  _TEXT	Length= 00C4 Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
BarCodeTable . . . . . . . . . .	Byte	 178B	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
ContadorBuffer . . . . . . . . .	Word	 0000	  _DATA	
Continua1  . . . . . . . . . . .	L Near	 0030	  _TEXT	
Continua2  . . . . . . . . . . .	L Near	 0050	  _TEXT	
Continua3  . . . . . . . . . . .	L Near	 0073	  _TEXT	
Continua4  . . . . . . . . . . .	L Near	 007A	  _TEXT	
FileBuffer . . . . . . . . . . .	Byte	 001B	  _DATA	
FileHandleDst  . . . . . . . . .	Word	 0019	  _DATA	
FileHandleSrc  . . . . . . . . .	Word	 0017	  _DATA	
FileNameDst  . . . . . . . . . .	Byte	 000F	  _DATA	
FileNameSrc  . . . . . . . . . .	Byte	 0008	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
MsgErroCreateFile  . . . . . . .	Byte	 17CD	  _DATA	
MsgErroOpenFile  . . . . . . . .	Byte	 1797	  _DATA	
MsgErroReadFile  . . . . . . . .	Byte	 1802	  _DATA	
MsgErroSemStart  . . . . . . . .	Byte	 1838	  _DATA	
MsgErroSemStop . . . . . . . . .	Byte	 1871	  _DATA	
MsgErroWriteFile . . . . . . . .	Byte	 18A9	  _DATA	
MsgErrorCaracterInvalido . . . .	Byte	 18DE	  _DATA	
NewBuffer  . . . . . . . . . . .	Byte	 07EB	  _DATA	
NomeTesteAleatorio . . . . . . .	Byte	 0002	  _DATA	
OutputBuffer . . . . . . . . . .	Byte	 0FBB	  _DATA	
TerminouArquivo  . . . . . . . .	L Near	 0083	  _TEXT	
criaNovoBuffer_end . . . . . . .	L Near	 0152	  _TEXT	
criaNovoBuffer_insere  . . . . .	L Near	 011E	  _TEXT	
criaNovoBuffer_loop2 . . . . . .	L Near	 011B	  _TEXT	
criaNovoBuffer_loop  . . . . . .	L Near	 00E8	  _TEXT	
criaNovoBuffer_print . . . . . .	L Near	 0163	  _TEXT	
criaNovoBuffer_sem_start . . . .	L Near	 0155	  _TEXT	
criaNovoBuffer_sem_stop  . . . .	L Near	 016B	  _TEXT	
loop_acha_primeiro_0 . . . . . .	L Near	 020E	  _TEXT	
loop_coloca_valores_0_acaba_final 	L Near	 0231	  _TEXT	
loop_coloca_valores_0_acaba  . .	L Near	 0227	  _TEXT	
loop_coloca_valores_0  . . . . .	L Near	 0214	  _TEXT	
loop_transformacoes  . . . . . .	L Near	 008E	  _TEXT	
ps_1 . . . . . . . . . . . . . .	L Near	 025A	  _TEXT	
transformaEmBarcode_codigo . . .	L Near	 01FF	  _TEXT	
transformaEmBarcode_erro_caractere_invalido  L Near   01F4     _TEXT	
transformaEmBarcode_fim_traducao .	L Near	 0233	  _TEXT	
transformaEmBarcode_loop . . . .	L Near	 017F	  _TEXT	
transforma_em_barcode_exec . . .	L Near	 0205	  _TEXT	

	   0 Warnings
	   0 Errors
