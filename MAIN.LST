Microsoft (R) Macro Assembler Version 6.11		    12/21/24 16:45:58
main.asm						     Page 1 - 1


				
				;
				;====================================================================
				;	- Escrever um programa para ler um arquivo texto e 
				;		apresentá-lo na tela
				;	- O usuário devem informar o nome do arquivo, 
				;		assim que for apresentada a mensagem: Nome do arquivo: 
				;====================================================================
				;
					.model		small
					.stack
						
 = 000D				CR		equ		0dh
 = 000A				LF		equ		0ah
				
 0000					.data
 0000 0000			ContadorBuffer  dw 	0
 0002 53 54 41 52 54 00		PalavraStart    db	"START", 0		; Palavra que indica o inicio da leitura
 0008 53 54 4F 50 00		PalavraStop     db	"STOP", 0		; Palavra que indica o fim da leitura
 000D 49 4E 2E 74 78 74		FileNameSrc		db		"IN.txt", 0	; Nome do arquivo a ser lido
       00
 0014 4F 55 54 2E 74 78		FileNameDst		db		"OUT.txt", 0		; Nome do arquivo a ser escrito
       74 00
 001C 0000			FileHandleSrc	dw		0				; Handler do arquivo origem
 001E 0000			FileHandleDst	dw		0				; Handler do arquivo destino
 0020  07D0 [			FileBuffer		db		2000 dup (?)		; Buffer de leitura/escrita do arquivo
        00
       ]
 07F0  07D0 [			NewBuffer		db		2000 dup (?)		; Buffer de leitura/escrita do arquivo
        00
       ]
				
 0FC0 4E 6F 6D 65 20 64		MsgPedeArquivoSrc	db	"Nome do arquivo origem: ", 0
       6F 20 61 72 71 75
       69 76 6F 20 6F 72
       69 67 65 6D 3A 20
       00
 0FD9 4E 6F 6D 65 20 64		MsgPedeArquivoDst	db	"Nome do arquivo destino: ", 0
       6F 20 61 72 71 75
       69 76 6F 20 64 65
       73 74 69 6E 6F 3A
       20 00
 0FF3 45 72 72 6F 20 6E		MsgErroOpenFile		db	"Erro na abertura do arquivo.", CR, LF, 0
       61 20 61 62 65 72
       74 75 72 61 20 64
       6F 20 61 72 71 75
       69 76 6F 2E 0D 0A
       00
 1012 45 72 72 6F 20 6E		MsgErroCreateFile	db	"Erro na criacao do arquivo.", CR, LF, 0
       61 20 63 72 69 61
       63 61 6F 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 1030 45 72 72 6F 20 6E		MsgErroReadFile		db	"Erro na leitura do arquivo.", CR, LF, 0
       61 20 6C 65 69 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 104E 45 72 72 6F 20 6E		MsgErroWriteFile	db	"Erro na escrita do arquivo.", CR, LF, 0
       61 20 65 73 63 72
       69 74 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 106C 0D 0A 00			MsgCRLF				db	CR, LF, 0
				
 = 00C8				MAXSTRING	equ		200
 106F  00C8 [			String	db		MAXSTRING dup (?)		; Usado na funcao gets
        00
       ]
				
 0000					.code
					.startup
				
					;GetFileNameSrc();	// Pega o nome do arquivo de origem -> FileNameSrc
					;call	GetFileNameSrc
				
					;if (fopen(FileNameSrc)) {
					;	printf("Erro na abertura do arquivo.\r\n")
					;	exit(1)
					;}
					;FileHandleSrc = BX
 0017  8D 16 000D R			lea		dx,FileNameSrc
 001B  E8 00C4				call	fopen
 001E  89 1E 001C R			mov		FileHandleSrc,bx
 0022  73 2C				jnc		Continua2
 0024  8D 1E 0FF3 R			lea		bx, MsgErroOpenFile
 0028  E8 0174				call	printf_s
					.exit	1
 0030				Continua1:
				
					;GetFileNameDst();	// Pega o nome do arquivo de origem -> FileNameDst
					;call	GetFileNameDst
					
					;if (fcreate(FileNameDst)) {
					;	fclose(FileHandleSrc);
					;	printf("Erro na criacao do arquivo.\r\n")
					;	exit(1)
					;}
					;FileHandleDst = BX
 0030  8D 16 0014 R			lea		dx,FileNameDst
 0034  E8 00B4				call	fcreate
 0037  89 1E 001E R			mov		FileHandleDst,bx
 003B  73 13				jnc		Continua2
 003D  8B 1E 001C R			mov		bx,FileHandleSrc
 0041  E8 00B1				call	fclose
 0044  8D 1E 1012 R			lea		bx, MsgErroCreateFile
 0048  E8 0154				call	printf_s
					.exit	1
 0050				Continua2:
				
					;do {
					;	if ( (CF,DL,AX = getChar(FileHandleSrc)) ) {
					;		printf("");
					;		fclose(FileHandleSrc)
					;		fclose(FileHandleDst)
					;		exit(1)
					;	}
 0050  8B 1E 001C R			mov		bx,FileHandleSrc    
 0054  E8 00A3				call	getChar
 0057  73 1A				jnc		Continua3
 0059  8D 1E 1030 R			lea		bx, MsgErroReadFile
 005D  E8 013F				call	printf_s
 0060  8B 1E 001C R			mov		bx,FileHandleSrc
 0064  E8 008E				call	fclose
 0067  8B 1E 001E R			mov		bx,FileHandleDst
 006B  E8 0087				call	fclose
					.exit	1
 0073				Continua3:
				
					;	if (AX==0) break;
 0073  83 F8 00				cmp		ax,0
 0076  74 1E				jz		TerminouArquivo
 0078  EB D6				jmp 	Continua2
 007A				Continua4:
				
					;	if ( setChar(FileHandleDst, DL) == 0) continue;
 007A  8B 1E 001E R			mov		bx,FileHandleDst
 007E  E8 00EA				call	setChar
 0081  73 CD				jnc		Continua2
					;jmp Continua2
					;	printf ("Erro na escrita....;)")
					;   fclose(FileHandleSrc)
					;   fclose(FileHandleDst)
					;   exit(1)
					;lea		bx, MsgErroWriteFile
					;call	printf_s
 0083  8B 1E 001C R			mov		bx,FileHandleSrc		; Fecha arquivo origem
 0087  E8 006B				call	fclose
 008A  8B 1E 001E R			mov		bx,FileHandleDst		; Fecha arquivo destino
 008E  E8 0064				call	fclose
					.exit	1
					
					;} while(1);
						
 0096				TerminouArquivo:
					;fclose(FileHandleSrc)
					;fclose(FileHandleDst)
					;exit(0)
 0096  C7 06 0000 R 0000		mov 	ContadorBuffer, 0	; Inicializa o contador de caracteres lidos
 009C  8D 1E 0020 R			lea 	bx, FileBuffer
 00A0  E8 006E				call    procuraStart
 00A3  8B 1E 001C R			mov		bx,FileHandleSrc	; Fecha arquivo origem
 00A7  E8 004B				call	fclose
 00AA  8B 1E 001E R			mov		bx,FileHandleDst	; Fecha arquivo destino
 00AE  E8 0044				call	fclose
					.exit	0
				
						
				;--------------------------------------------------------------------
				;Funcao Pede o nome do arquivo de origem salva-o em FileNameSrc
				;--------------------------------------------------------------------
 00B6				GetFileNameSrc	proc	near
					;printf("Nome do arquivo origem: ")
 00B6  8D 1E 0FC0 R			lea		bx, MsgPedeArquivoSrc
 00BA  E8 00E2				call	printf_s
				
					;gets(FileNameSrc);
 00BD  8D 1E 000D R			lea		bx, FileNameSrc
 00C1  E8 00B7				call	gets
					
					;printf("\r\n")
 00C4  8D 1E 106C R			lea		bx, MsgCRLF
 00C8  E8 00D4				call	printf_s
					
 00CB  C3				ret
 00CC				GetFileNameSrc	endp
				
				
				;--------------------------------------------------------------------
				;Funcao Pede o nome do arquivo de destino salva-o em FileNameDst
				;--------------------------------------------------------------------
 00CC				GetFileNameDst	proc	near
					;printf("Nome do arquivo destino: ");
 00CC  8D 1E 0FD9 R			lea		bx, MsgPedeArquivoDst
 00D0  E8 00CC				call	printf_s
					
					;gets(FileNameDst);
 00D3  8D 1E 0014 R			lea		bx, FileNameDst
 00D7  E8 00A1				call	gets
					
					;printf("\r\n")
 00DA  8D 1E 106C R			lea		bx, MsgCRLF
 00DE  E8 00BE				call	printf_s
					
 00E1  C3				ret
 00E2				GetFileNameDst	endp
				
				;--------------------------------------------------------------------
				;Função	Abre o arquivo cujo nome está no string apontado por DX
				;		boolean fopen(char *FileName -> DX)
				;Entra: DX -> ponteiro para o string com o nome do arquivo
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00E2				fopen	proc	near
 00E2  B0 00				mov		al,0
 00E4  B4 3D				mov		ah,3dh
 00E6  CD 21				int		21h
 00E8  8B D8				mov		bx,ax
 00EA  C3				ret
 00EB				fopen	endp
				
				;--------------------------------------------------------------------
				;Função Cria o arquivo cujo nome está no string apontado por DX
				;		boolean fcreate(char *FileName -> DX)
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00EB				fcreate	proc	near
 00EB  B9 0000				mov		cx,0
 00EE  B4 3C				mov		ah,3ch
 00F0  CD 21				int		21h
 00F2  8B D8				mov		bx,ax
 00F4  C3				ret
 00F5				fcreate	endp
				
				;--------------------------------------------------------------------
				;Entra:	BX -> file handle
				;Sai:	CF -> "0" se OK
				;--------------------------------------------------------------------
 00F5				fclose	proc	near
 00F5  B4 3E				mov		ah,3eh
 00F7  CD 21				int		21h
 00F9  C3				ret
 00FA				fclose	endp
				
				;--------------------------------------------------------------------
				;Função	Le um caractere do arquivo identificado pelo HANLDE BX
				;		getChar(handle->BX)
				;Entra: BX -> file handle
				;Sai:   
				;		AX -> numero de caracteres lidos
				;		CF -> "0" se leitura ok
				;--------------------------------------------------------------------
				
 00FA				getChar proc near
 00FA  B9 0001			    mov     cx, 1                  ; Number of bytes to read
 00FD  8D 36 0020 R		    lea     si, FileBuffer         ; Load the base address of FileBuffer into SI
 0101  8B D6			    mov     dx, si                 ; Copy base address to DX (used by DOS)
 0103  A1 0000 R		    mov     ax, ContadorBuffer     ; Load FileCounter into AX
 0106  03 D0			    add     dx, ax                 ; Adjust DX to point to the current position
 0108  B4 3F			    mov     ah, 3Fh                ; DOS function: Read from file
 010A  CD 21			    int     21h                    ; Call DOS interrupt
 010C  FF 06 0000 R		    inc     ContadorBuffer         ; Increment the counter for the next read
 0110  C3			    ret                            ; Return to the caller
 0111				getChar endp
				
 0111				procuraStart    proc near
				
				
 0111  8D 1E 0020 R			lea bx, FileBuffer
 0115  E8 0087				call printf_s
				
 0118				procuraStart_loop:
 0118  8A 17				mov 	dl, [bx]	; Carrega o primeiro caractere do buffer
				    
 011A  B9 0001			    mov     cx, 1                  ; Number of bytes to read
 011D  8D 36 0020 R		    lea     si, FileBuffer         ; Load the base address of FileBuffer into SI
 0121  8B D6			    mov     dx, si                 ; Copy base address to DX (used by DOS)
 0123  A1 0000 R		    mov     ax, ContadorBuffer     ; Load FileCounter into AX
 0126  03 D0			    add     dx, ax                 ; Adjust DX to point to the current position
 0128  B4 3F			    mov     ah, 3Fh                ; DOS function: Read from file
 012A  CD 21			    int     21h                    ; Call DOS interrupt
 012C  FF 06 0000 R		    inc     ContadorBuffer         ; Increment the counter for the next read
				
 0130  80 FA 00				cmp 	dl, 0		; Verifica se o buffer está vazio
 0133  74 2D				je 		procuraStart_ret	; Se estiver, retorna
				
 0135  80 FA 53				cmp     dl, 'S'             ; Verifica se o caractere é 'S'
 0138  75 25				jne     procuraStart_end    ; Se não for, sai do loop
				
 013A  8A 57 01				mov dl, [bx + 1]
				
 013D  80 FA 54				cmp     byte ptr dl, 'T'  ; Verifica se o próximo caractere é 'T'
 0140  75 1D				jne     procuraStart_end    ; Se não for, sai do loop
				
 0142  8A 57 02				mov dl, [bx + 2]
				
 0145  80 FA 41				cmp     byte ptr dl, 'A'; Verifica se o próximo caractere é 'A'
 0148  75 15				jne     procuraStart_end    ; Se não for, sai do loop
				
 014A  8A 57 03				mov dl, [bx + 3]
				
 014D  80 FA 52				cmp     byte ptr dl, 'R'; Verifica se o próximo caractere é 'R'
 0150  75 0D				jne     procuraStart_end    ; Se não for, sai do loop
				
 0152  8A 57 04				mov dl, [bx + 4]
				
 0155  80 FA 54				cmp     byte ptr dl, 'T'; Verifica se o próximo caractere é 'T'
 0158  75 05				jne     procuraStart_end    ; Se não for, sai do loop
				
 015A  8A 57 05				mov dl, [bx + 5]	; Adicione essa linha para verificar o próximo caractere
				
 015D  EB 04				jmp     procuraStart_print   ; Imprime a mensagem
				
				
 015F				procuraStart_end:
 015F  43				inc bx
 0160  72 B6				jb      procuraStart_loop    ; Se não chegou, continua procurando
				
				
 0162				procuraStart_ret:
 0162  C3				ret
				
 0163				procuraStart_print:
 0163  8D 1E 0002 R			lea     bx, PalavraStart
 0167  E8 0035				call    printf_s
 016A  C3				ret
				
 016B				procuraStart    endp
				
				;--------------------------------------------------------------------
				;Entra: BX -> file handle
				;       dl -> caractere
				;Sai:   AX -> numero de caracteres escritos
				;		CF -> "0" se escrita ok
				;--------------------------------------------------------------------
 016B				setChar	proc	near
 016B  B4 40				mov		ah,40h
 016D  B9 0001				mov		cx,1
 0170  88 16 0020 R			mov		FileBuffer,dl
 0174  8D 16 0020 R			lea		dx,FileBuffer
 0178  CD 21				int		21h
 017A  C3				ret
 017B				setChar	endp	
				
				;
				;--------------------------------------------------------------------
				;Funcao Le um string do teclado e coloca no buffer apontado por BX
				;		gets(char *s -> bx)
				;--------------------------------------------------------------------
 017B				gets	proc	near
 017B  53				push	bx
				
 017C  B4 0A				mov		ah,0ah						; Lê uma linha do teclado
 017E  8D 16 106F R			lea		dx,String
 0182  C6 06 106F R C4			mov		byte ptr String, MAXSTRING-4	; 2 caracteres no inicio e um eventual CR LF no final
 0187  CD 21				int		21h
				
 0189  8D 36 1071 R			lea		si,String+2					; Copia do buffer de teclado para o FileName
 018D  5F				pop		di
 018E  8A 0E 1070 R			mov		cl,String+1
 0192  B5 00				mov		ch,0
 0194  8C D8				mov		ax,ds						; Ajusta ES=DS para poder usar o MOVSB
 0196  8E C0				mov		es,ax
 0198  F3/ A4				rep 	movsb
				
 019A  26: C6 05 00			mov		byte ptr es:[di],0			; Coloca marca de fim de string
 019E  C3				ret
 019F				gets	endp
				
				;====================================================================
				; A partir daqui, estão as funções já desenvolvidas
				;	1) printf_s
				;====================================================================
					
				;--------------------------------------------------------------------
				;Função Escrever um string na tela
				;		printf_s(char *s -> BX)
				;--------------------------------------------------------------------
 019F				printf_s	proc	near
 019F  8A 17				mov		dl,[bx]
 01A1  80 FA 00				cmp		dl,0
 01A4  74 09				je		ps_1
				
 01A6  53				push	bx
 01A7  B4 02				mov		ah,2
 01A9  CD 21				int		21H
 01AB  5B				pop		bx
				
 01AC  43				inc		bx		
 01AD  EB F0				jmp		printf_s
						
 01AF				ps_1:
 01AF  C3				ret
 01B0				printf_s	endp
				
				;--------------------------------------------------------------------
						end
				;--------------------------------------------------------------------
				
				
					
				
				

Microsoft (R) Macro Assembler Version 6.11		    12/21/24 16:45:58
main.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 1137	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 01B0	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

GetFileNameDst . . . . . . . . .	P Near	 00CC	  _TEXT	Length= 0016 Private
GetFileNameSrc . . . . . . . . .	P Near	 00B6	  _TEXT	Length= 0016 Private
fclose . . . . . . . . . . . . .	P Near	 00F5	  _TEXT	Length= 0005 Private
fcreate  . . . . . . . . . . . .	P Near	 00EB	  _TEXT	Length= 000A Private
fopen  . . . . . . . . . . . . .	P Near	 00E2	  _TEXT	Length= 0009 Private
getChar  . . . . . . . . . . . .	P Near	 00FA	  _TEXT	Length= 0017 Private
gets . . . . . . . . . . . . . .	P Near	 017B	  _TEXT	Length= 0024 Private
printf_s . . . . . . . . . . . .	P Near	 019F	  _TEXT	Length= 0011 Private
procuraStart . . . . . . . . . .	P Near	 0111	  _TEXT	Length= 005A Private
setChar  . . . . . . . . . . . .	P Near	 016B	  _TEXT	Length= 0010 Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
ContadorBuffer . . . . . . . . .	Word	 0000	  _DATA	
Continua1  . . . . . . . . . . .	L Near	 0030	  _TEXT	
Continua2  . . . . . . . . . . .	L Near	 0050	  _TEXT	
Continua3  . . . . . . . . . . .	L Near	 0073	  _TEXT	
Continua4  . . . . . . . . . . .	L Near	 007A	  _TEXT	
FileBuffer . . . . . . . . . . .	Byte	 0020	  _DATA	
FileHandleDst  . . . . . . . . .	Word	 001E	  _DATA	
FileHandleSrc  . . . . . . . . .	Word	 001C	  _DATA	
FileNameDst  . . . . . . . . . .	Byte	 0014	  _DATA	
FileNameSrc  . . . . . . . . . .	Byte	 000D	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
MAXSTRING  . . . . . . . . . . .	Number	 00C8h	 
MsgCRLF  . . . . . . . . . . . .	Byte	 106C	  _DATA	
MsgErroCreateFile  . . . . . . .	Byte	 1012	  _DATA	
MsgErroOpenFile  . . . . . . . .	Byte	 0FF3	  _DATA	
MsgErroReadFile  . . . . . . . .	Byte	 1030	  _DATA	
MsgErroWriteFile . . . . . . . .	Byte	 104E	  _DATA	
MsgPedeArquivoDst  . . . . . . .	Byte	 0FD9	  _DATA	
MsgPedeArquivoSrc  . . . . . . .	Byte	 0FC0	  _DATA	
NewBuffer  . . . . . . . . . . .	Byte	 07F0	  _DATA	
PalavraStart . . . . . . . . . .	Byte	 0002	  _DATA	
PalavraStop  . . . . . . . . . .	Byte	 0008	  _DATA	
String . . . . . . . . . . . . .	Byte	 106F	  _DATA	
TerminouArquivo  . . . . . . . .	L Near	 0096	  _TEXT	
procuraStart_end . . . . . . . .	L Near	 015F	  _TEXT	
procuraStart_loop  . . . . . . .	L Near	 0118	  _TEXT	
procuraStart_print . . . . . . .	L Near	 0163	  _TEXT	
procuraStart_ret . . . . . . . .	L Near	 0162	  _TEXT	
ps_1 . . . . . . . . . . . . . .	L Near	 01AF	  _TEXT	

	   0 Warnings
	   0 Errors
