Microsoft (R) Macro Assembler Version 6.11		    12/21/24 17:57:08
main.asm						     Page 1 - 1


				
				;
				;====================================================================
				;	- Escrever um programa para ler um arquivo texto e 
				;		apresentá-lo na tela
				;	- O usuário devem informar o nome do arquivo, 
				;		assim que for apresentada a mensagem: Nome do arquivo: 
				;====================================================================
				;
					.model		small
					.stack
						
 = 000D				CR		equ		0dh
 = 000A				LF		equ		0ah
				
 0000					.data
				
 0000 0000			ContadorBuffer  dw 	0
 0002 53 54 41 52 54 00		PalavraStart    db		"START", 0		; Palavra que indica o inicio da leitura
 0008 53 54 4F 50 00		PalavraStop     db		"STOP", 0		; Palavra que indica o fim da leitura
 000D 49 4E 2E 74 78 74		FileNameSrc		db		"IN.txt", 0		; Nome do arquivo a ser lido
       00
 0014 4F 55 54 2E 74 78		FileNameDst		db		"OUT.txt", 0	; Nome do arquivo a ser escrito
       74 00
 001C 0000			FileHandleSrc	dw		0				; Handler do arquivo origem
 001E 0000			FileHandleDst	dw		0				; Handler do arquivo destino
 0020  07D0 [			FileBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 07F0  07D0 [			NewBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
				
 0FC0 4E 6F 6D 65 20 64		MsgPedeArquivoSrc	db	"Nome do arquivo origem: ", 0
       6F 20 61 72 71 75
       69 76 6F 20 6F 72
       69 67 65 6D 3A 20
       00
 0FD9 4E 6F 6D 65 20 64		MsgPedeArquivoDst	db	"Nome do arquivo destino: ", 0
       6F 20 61 72 71 75
       69 76 6F 20 64 65
       73 74 69 6E 6F 3A
       20 00
 0FF3 45 72 72 6F 3A 20		MsgErroOpenFile		db	"Erro: Nao foi possivel fazer a abertura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 61 62 65 72 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 1029 45 72 72 6F 3A 20		MsgErroCreateFile	db	"Erro: Nao foi possivel fazer a criacao do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 63 72 69 61 63
       61 6F 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 105E 45 72 72 6F 3A 20		MsgErroReadFile		db	"Erro: Nao foi possível fazer a leitura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       C3 AD 76 65 6C 20
       66 61 7A 65 72 20
       61 20 6C 65 69 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 1094 45 72 72 6F 3A 20		MsgErroSemStart		db	"Erro: Nao foi encontrado a palavra 'START' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 41 52 54 27
       20 6E 6F 20 61 72
       71 75 69 76 6F 2E
       0D 0A 00
 10CD 45 72 72 6F 3A 20		MsgErroWriteFile	db	"Erro: Nao foi possivel fazer a escrita do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 65 73 63 72 69
       74 61 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 1102 0D 0A 00			MsgCRLF				db	CR, LF, 0
				
 0000					.code
					.startup
				
					;GetFileNameSrc();	// Pega o nome do arquivo de origem -> FileNameSrc
					;call	GetFileNameSrc
				
					;if (fopen(FileNameSrc)) {
					;	printf("Erro na abertura do arquivo.\r\n")
					;	exit(1)
					;}
					;FileHandleSrc = BX
 0017  8D 16 000D R			lea		dx,FileNameSrc
 001B  E8 008E				call	fopen
 001E  89 1E 001C R			mov		FileHandleSrc,bx
 0022  73 2C				jnc		Continua2
 0024  8D 1E 0FF3 R			lea		bx, MsgErroOpenFile
 0028  E8 0111				call	printf_s
					.exit	1
 0030				Continua1:
				
					;GetFileNameDst();	// Pega o nome do arquivo de origem -> FileNameDst
					;call	GetFileNameDst
					
					;if (fcreate(FileNameDst)) {
					;	fclose(FileHandleSrc);
					;	printf("Erro na criacao do arquivo.\r\n")
					;	exit(1)
					;}
					;FileHandleDst = BX
 0030  8D 16 0014 R			lea		dx,FileNameDst
 0034  E8 007E				call	fcreate
 0037  89 1E 001E R			mov		FileHandleDst,bx
 003B  73 13				jnc		Continua2
 003D  8B 1E 001C R			mov		bx,FileHandleSrc
 0041  E8 007B				call	fclose
 0044  8D 1E 1029 R			lea		bx, MsgErroCreateFile
 0048  E8 00F1				call	printf_s
					.exit	1
 0050				Continua2:
				
 0050  8B 1E 001C R			mov		bx,FileHandleSrc    
 0054  E8 006D				call	getChar
 0057  73 1A				jnc		Continua3
 0059  8D 1E 105E R			lea		bx, MsgErroReadFile
 005D  E8 00DC				call	printf_s
 0060  8B 1E 001C R			mov		bx,FileHandleSrc
 0064  E8 0058				call	fclose
 0067  8B 1E 001E R			mov		bx,FileHandleDst
 006B  E8 0051				call	fclose
					.exit	1
 0073				Continua3:
				
 0073  83 F8 00				cmp		ax,0
 0076  74 1E				jz		TerminouArquivo
 0078  EB D6				jmp 	Continua2
 007A				Continua4:
				
 007A  8B 1E 001E R			mov		bx,FileHandleDst
 007E  E8 00AB				call	setChar
 0081  73 CD				jnc		Continua2
				
 0083  8B 1E 001C R			mov		bx,FileHandleSrc		; Fecha arquivo origem
 0087  E8 0035				call	fclose
 008A  8B 1E 001E R			mov		bx,FileHandleDst		; Fecha arquivo destino
 008E  E8 002E				call	fclose
					.exit	1
					
 0096				TerminouArquivo:
				
 0096  E8 0042				call    procuraStart
 0099  8B 1E 001C R			mov		bx,FileHandleSrc	; Fecha arquivo origem
 009D  E8 001F				call	fclose
 00A0  8B 1E 001E R			mov		bx,FileHandleDst	; Fecha arquivo destino
 00A4  E8 0018				call	fclose
					.exit	0
				
				
				;--------------------------------------------------------------------
				;Função	Abre o arquivo cujo nome está no string apontado por DX
				;		boolean fopen(char *FileName -> DX)
				;Entra: DX -> ponteiro para o string com o nome do arquivo
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00AC				fopen	proc	near
 00AC  B0 00				mov		al,0
 00AE  B4 3D				mov		ah,3dh
 00B0  CD 21				int		21h
 00B2  8B D8				mov		bx,ax
 00B4  C3				ret
 00B5				fopen	endp
				
				;--------------------------------------------------------------------
				;Função Cria o arquivo cujo nome está no string apontado por DX
				;		boolean fcreate(char *FileName -> DX)
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00B5				fcreate	proc	near
 00B5  B9 0000				mov		cx,0
 00B8  B4 3C				mov		ah,3ch
 00BA  CD 21				int		21h
 00BC  8B D8				mov		bx,ax
 00BE  C3				ret
 00BF				fcreate	endp
				
				;--------------------------------------------------------------------
				;Entra:	BX -> file handle
				;Sai:	CF -> "0" se OK
				;--------------------------------------------------------------------
 00BF				fclose	proc	near
 00BF  B4 3E				mov		ah,3eh
 00C1  CD 21				int		21h
 00C3  C3				ret
 00C4				fclose	endp
				
				;--------------------------------------------------------------------
				;Função	Le um caractere do arquivo identificado pelo HANLDE BX
				;		getChar(handle->BX)
				;Entra: BX -> file handle
				;Sai:   
				;		AX -> numero de caracteres lidos
				;		CF -> "0" se leitura ok
				;--------------------------------------------------------------------
 00C4				getChar proc near
 00C4  B9 0001			    mov     cx, 1                  ; Number of bytes to read
 00C7  8D 36 0020 R		    lea     si, FileBuffer         ; Load the base address of FileBuffer into SI
 00CB  8B D6			    mov     dx, si                 ; Copy base address to DX (used by DOS)
 00CD  A1 0000 R		    mov     ax, ContadorBuffer     ; Load FileCounter into AX
 00D0  03 D0			    add     dx, ax                 ; Adjust DX to point to the current position
 00D2  B4 3F			    mov     ah, 3Fh                ; DOS function: Read from file
 00D4  CD 21			    int     21h                    ; Call DOS interrupt
 00D6  FF 06 0000 R		    inc     ContadorBuffer         ; Increment the counter for the next read
 00DA  C3			    ret                            ; Return to the caller
 00DB				getChar endp
				
				;--------------------------------------------------------------------
				;Função que procura a palavra "START" no arquivo
				;		
				;Sai:   
				;		NovoBuffer -> buffer com o conteudo do arquivo
				;--------------------------------------------------------------------
 00DB				procuraStart    proc near
 00DB  8D 1E 0020 R			lea bx, FileBuffer
				
 00DF				procuraStart_loop:
 00DF  8A 17				mov 	dl, [bx]	; Carrega o primeiro caractere do buffer
					
 00E1  80 FA 00				cmp 	dl, 0		; Verifica se o buffer está vazio
 00E4  74 30				je 		procuraStart_ret	; Se estiver, retorna
				
 00E6  80 FA 53				cmp     byte ptr dl, 'S'             ; Verifica se o caractere é 'S'
 00E9  75 28				jne     procuraStart_end    ; Se não for, sai do loop
				
 00EB  8A 57 01				mov dl, [bx + 1]
				
 00EE  80 FA 54				cmp     byte ptr dl, 'T'  ; Verifica se o próximo caractere é 'T'
 00F1  75 20				jne     procuraStart_end    ; Se não for, sai do loop
				
 00F3  8A 57 02				mov dl, [bx + 2]
				
 00F6  80 FA 41				cmp     byte ptr dl, 'A'; Verifica se o próximo caractere é 'A'
 00F9  75 18				jne     procuraStart_end    ; Se não for, sai do loop
				
 00FB  8A 57 03				mov dl, [bx + 3]
				
 00FE  80 FA 52				cmp     byte ptr dl, 'R'; Verifica se o próximo caractere é 'R'
 0101  75 10				jne     procuraStart_end    ; Se não for, sai do loop
				
 0103  8A 57 04				mov dl, [bx + 4]
				
 0106  80 FA 54				cmp     byte ptr dl, 'T'; Verifica se o próximo caractere é 'T'
 0109  75 08				jne     procuraStart_end    ; Se não for, sai do loop
				
 010B  8A 57 05				mov dl, [bx + 5]	; Adicione essa linha para verificar o próximo caractere
				
 010E  80 FA 00				cmp     byte ptr dl, 0 ; Verifica se o próximo caractere é nulo
 0111  75 11				jne     procuraStart_print   ; Imprime a mensagem
				
 0113				procuraStart_end:
 0113  43				inc bx
 0114  EB C9				jmp procuraStart_loop
				
 0116				procuraStart_ret:
 0116  83 F9 00				cmp cx, 0
 0119  8D 1E 1094 R			lea bx, MsgErroSemStart
 011D  E8 001C				call printf_s
					.exit
				
 0124				procuraStart_print:
 0124  8D 1E 0002 R			lea bx, PalavraStart
 0128  E8 0011				call printf_s
 012B  C3				ret
				
 012C				procuraStart    endp
				
				;--------------------------------------------------------------------
				;Entra: BX -> file handle
				;       dl -> caractere
				;Sai:   AX -> numero de caracteres escritos
				;		CF -> "0" se escrita ok
				;--------------------------------------------------------------------
 012C				setChar	proc	near
 012C  B4 40				mov		ah,40h
 012E  B9 0001				mov		cx,1
 0131  88 16 0020 R			mov		FileBuffer,dl
 0135  8D 16 0020 R			lea		dx,FileBuffer
 0139  CD 21				int		21h
 013B  C3				ret
 013C				setChar	endp	
				
				;====================================================================
				; A partir daqui, estão as funções já desenvolvidas
				;	1) printf_s
				;====================================================================
					
				;--------------------------------------------------------------------
				;Função Escrever um string na tela
				;		printf_s(char *s -> BX)
				;--------------------------------------------------------------------
 013C				printf_s	proc	near
 013C  8A 17				mov		dl,[bx]
 013E  80 FA 00				cmp		dl,0
 0141  74 09				je		ps_1
				
 0143  53				push	bx
 0144  B4 02				mov		ah,2
 0146  CD 21				int		21H
 0148  5B				pop		bx
				
 0149  43				inc		bx		
 014A  EB F0				jmp		printf_s
						
 014C				ps_1:
 014C  C3				ret
 014D				printf_s	endp
				
				;--------------------------------------------------------------------
						end
				;--------------------------------------------------------------------
				
				
					
				
				

Microsoft (R) Macro Assembler Version 6.11		    12/21/24 17:57:08
main.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 1105	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 014D	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

fclose . . . . . . . . . . . . .	P Near	 00BF	  _TEXT	Length= 0005 Private
fcreate  . . . . . . . . . . . .	P Near	 00B5	  _TEXT	Length= 000A Private
fopen  . . . . . . . . . . . . .	P Near	 00AC	  _TEXT	Length= 0009 Private
getChar  . . . . . . . . . . . .	P Near	 00C4	  _TEXT	Length= 0017 Private
printf_s . . . . . . . . . . . .	P Near	 013C	  _TEXT	Length= 0011 Private
procuraStart . . . . . . . . . .	P Near	 00DB	  _TEXT	Length= 0051 Private
setChar  . . . . . . . . . . . .	P Near	 012C	  _TEXT	Length= 0010 Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
ContadorBuffer . . . . . . . . .	Word	 0000	  _DATA	
Continua1  . . . . . . . . . . .	L Near	 0030	  _TEXT	
Continua2  . . . . . . . . . . .	L Near	 0050	  _TEXT	
Continua3  . . . . . . . . . . .	L Near	 0073	  _TEXT	
Continua4  . . . . . . . . . . .	L Near	 007A	  _TEXT	
FileBuffer . . . . . . . . . . .	Byte	 0020	  _DATA	
FileHandleDst  . . . . . . . . .	Word	 001E	  _DATA	
FileHandleSrc  . . . . . . . . .	Word	 001C	  _DATA	
FileNameDst  . . . . . . . . . .	Byte	 0014	  _DATA	
FileNameSrc  . . . . . . . . . .	Byte	 000D	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
MsgCRLF  . . . . . . . . . . . .	Byte	 1102	  _DATA	
MsgErroCreateFile  . . . . . . .	Byte	 1029	  _DATA	
MsgErroOpenFile  . . . . . . . .	Byte	 0FF3	  _DATA	
MsgErroReadFile  . . . . . . . .	Byte	 105E	  _DATA	
MsgErroSemStart  . . . . . . . .	Byte	 1094	  _DATA	
MsgErroWriteFile . . . . . . . .	Byte	 10CD	  _DATA	
MsgPedeArquivoDst  . . . . . . .	Byte	 0FD9	  _DATA	
MsgPedeArquivoSrc  . . . . . . .	Byte	 0FC0	  _DATA	
NewBuffer  . . . . . . . . . . .	Byte	 07F0	  _DATA	
PalavraStart . . . . . . . . . .	Byte	 0002	  _DATA	
PalavraStop  . . . . . . . . . .	Byte	 0008	  _DATA	
TerminouArquivo  . . . . . . . .	L Near	 0096	  _TEXT	
procuraStart_end . . . . . . . .	L Near	 0113	  _TEXT	
procuraStart_loop  . . . . . . .	L Near	 00DF	  _TEXT	
procuraStart_print . . . . . . .	L Near	 0124	  _TEXT	
procuraStart_ret . . . . . . . .	L Near	 0116	  _TEXT	
ps_1 . . . . . . . . . . . . . .	L Near	 014C	  _TEXT	

	   0 Warnings
	   0 Errors
