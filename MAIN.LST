Microsoft (R) Macro Assembler Version 6.11		    12/23/24 23:35:33
main.asm						     Page 1 - 1


				
				;
				;====================================================================
				;	- Escrever um programa para ler um arquivo texto e 
				;		apresentá-lo na tela
				;	- O usuário devem informar o nome do arquivo, 
				;		assim que for apresentada a mensagem: Nome do arquivo: 
				;====================================================================
				;
					.model		small
					.stack
						
 = 000D				CR		equ		0dh
 = 000A				LF		equ		0ah
				
 0000					.data
				
 0000 0000			ContadorBuffer  dw 	0
 0002 54 65 73 74 65 00		NomeTesteAleatorio db 	"Teste", 0
 0008 49 4E 2E 74 78 74		FileNameSrc		db		"IN.txt", 0		; Nome do arquivo a ser lido
       00
 000F 4F 55 54 2E 74 78		FileNameDst		db		"OUT.txt", 0	; Nome do arquivo a ser escrito
       74 00
 0017 0000			FileHandleSrc	dw		0				; Handler do arquivo origem
 0019 0000			FileHandleDst	dw		0				; Handler do arquivo destino
 001B  07D0 [			FileBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 07EB  07D0 [			NewBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 0FBB  07D0 [			OutputBuffer    db 		2000 dup(?) 	; Espaço para os BarCodes (64 bytes)
        00
       ]
				
				
 178B 2B			BarCodeTable DB 101011b     ; 0
 178C  6B				DB 1101011b    ; 1
 178D  4B				DB 1001011b    ; 2
 178E  65				DB 1100101b    ; 3
 178F  5B				DB 1011011b    ; 4
 1790  6D				DB 1101101b    ; 5
 1791  4D				DB 1001101b    ; 6
 1792  53				DB 1010011b    ; 7
 1793  69				DB 1101001b    ; 8
 1794  6D				DB 1101101b    ; 9
 1795  2D				DB 101101b     ; -
 1796  59				DB 1011001b    ; SS
				
				
				
 1797 45 72 72 6F 3A 20		MsgErroOpenFile		db	"Erro: Nao foi possivel fazer a abertura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 61 62 65 72 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 17CD 45 72 72 6F 3A 20		MsgErroCreateFile	db	"Erro: Nao foi possivel fazer a criacao do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 63 72 69 61 63
       61 6F 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 1802 45 72 72 6F 3A 20		MsgErroReadFile		db	"Erro: Nao foi possível fazer a leitura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       C3 AD 76 65 6C 20
       66 61 7A 65 72 20
       61 20 6C 65 69 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 1838 45 72 72 6F 3A 20		MsgErroSemStart		db	"Erro: Nao foi encontrado a palavra 'START' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 41 52 54 27
       20 6E 6F 20 61 72
       71 75 69 76 6F 2E
       0D 0A 00
 1871 45 72 72 6F 3A 20		MsgErroSemStop		db	"Erro: Nao foi encontrado a palavra 'STOP' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 4F 50 27 20
       6E 6F 20 61 72 71
       75 69 76 6F 2E 0D
       0A 00
 18A9 45 72 72 6F 3A 20		MsgErroWriteFile	db	"Erro: Nao foi possivel fazer a escrita do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 65 73 63 72 69
       74 61 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 18DE 45 72 72 6F 3A 20		MsgErrorCaracterInvalido db "Erro: Nao foi possivel fazer a traducao de um caracter que eh invalido.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 74 72 61 64 75
       63 61 6F 20 64 65
       20 75 6D 20 63 61
       72 61 63 74 65 72
       20 71 75 65 20 65
       68 20 69 6E 76 61
       6C 69 64 6F 2E 0D
       0A 00
				
 0000					.code
					.startup
				
 0017  8D 16 0008 R			lea		dx,FileNameSrc
 001B  E8 0085				call	fopen
 001E  89 1E 0017 R			mov		FileHandleSrc,bx
 0022  73 2C				jnc		Continua2
 0024  8D 1E 1797 R			lea		bx, MsgErroOpenFile
 0028  E8 020F				call	printf_s
					.exit	1
 0030				Continua1:
				
 0030  8D 16 000F R			lea		dx,FileNameDst
 0034  E8 0075				call	fcreate
 0037  89 1E 0019 R			mov		FileHandleDst,bx
 003B  73 13				jnc		Continua2
 003D  8B 1E 0017 R			mov		bx,FileHandleSrc
 0041  E8 0072				call	fclose
 0044  8D 1E 17CD R			lea		bx, MsgErroCreateFile
 0048  E8 01EF				call	printf_s
					.exit	1
 0050				Continua2:
				
 0050  8B 1E 0017 R			mov		bx,FileHandleSrc    
 0054  E8 0064				call	getChar
 0057  73 1A				jnc		Continua3
 0059  8D 1E 1802 R			lea		bx, MsgErroReadFile
 005D  E8 01DA				call	printf_s
 0060  8B 1E 0017 R			mov		bx,FileHandleSrc
 0064  E8 004F				call	fclose
 0067  8B 1E 0019 R			mov		bx,FileHandleDst
 006B  E8 0048				call	fclose
					.exit	1
 0073				Continua3:
				
 0073  83 F8 00				cmp		ax,0
 0076  74 0B				jz		TerminouArquivo
 0078  EB D6				jmp 	Continua2
 007A				Continua4:
				
 007A  8B 1E 0019 R			mov		bx,FileHandleDst
 007E  E8 01A9				call	setChar
 0081  73 CD				jnc		Continua2
					
 0083				TerminouArquivo:
				
 0083  E8 004C				call    criaNovoBuffer
				
 0086  E8 00E6				call    transformaEmBarcode
				
				
 0089  8D 1E 0FBB R			lea 	bx, OutputBuffer
 008D  E8 01AA				call 	printf_s
				
				
				
 0090  8B 1E 0017 R			mov		bx,FileHandleSrc	; Fecha arquivo origem
 0094  E8 001F				call	fclose
 0097  8B 1E 0019 R			mov		bx,FileHandleDst	; Fecha arquivo destino
 009B  E8 0018				call	fclose
					.exit	0
				
				
				;--------------------------------------------------------------------
				;Função	Abre o arquivo cujo nome está no string apontado por DX
				;		boolean fopen(char *FileName -> DX)
				;Entra: DX -> ponteiro para o string com o nome do arquivo
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00A3				fopen	proc	near
 00A3  B0 00				mov		al,0
 00A5  B4 3D				mov		ah,3dh
 00A7  CD 21				int		21h
 00A9  8B D8				mov		bx,ax
 00AB  C3				ret
 00AC				fopen	endp
				
				;--------------------------------------------------------------------
				;Função Cria o arquivo cujo nome está no string apontado por DX
				;		boolean fcreate(char *FileName -> DX)
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00AC				fcreate	proc	near
 00AC  B9 0000				mov		cx,0
 00AF  B4 3C				mov		ah,3ch
 00B1  CD 21				int		21h
 00B3  8B D8				mov		bx,ax
 00B5  C3				ret
 00B6				fcreate	endp
				
				;--------------------------------------------------------------------
				;Entra:	BX -> file handle
				;Sai:	CF -> "0" se OK
				;--------------------------------------------------------------------
 00B6				fclose	proc	near
 00B6  B4 3E				mov		ah,3eh
 00B8  CD 21				int		21h
 00BA  C3				ret
 00BB				fclose	endp
				
				;--------------------------------------------------------------------
				;Função	Le um caractere do arquivo identificado pelo HANLDE BX
				;		getChar(handle->BX)
				;Entra: BX -> file handle
				;Sai:   
				;		AX -> numero de caracteres lidos
				;		CF -> "0" se leitura ok
				;--------------------------------------------------------------------
 00BB				getChar proc near
 00BB  B9 0001			    mov     cx, 1                  ; Number of bytes to read
 00BE  8D 36 001B R		    lea     si, FileBuffer         ; Load the base address of FileBuffer into SI
 00C2  8B D6			    mov     dx, si                 ; Copy base address to DX (used by DOS)
 00C4  A1 0000 R		    mov     ax, ContadorBuffer     ; Load FileCounter into AX
 00C7  03 D0			    add     dx, ax                 ; Adjust DX to point to the current position
 00C9  B4 3F			    mov     ah, 3Fh                ; DOS function: Read from file
 00CB  CD 21			    int     21h                    ; Call DOS interrupt
 00CD  FF 06 0000 R		    inc     ContadorBuffer         ; Increment the counter for the next read
 00D1  C3			    ret                            ; Return to the caller
 00D2				getChar endp
				
				;--------------------------------------------------------------------
				;Função que cria um novo buffer com o conteudo do arquivo que interessa
				;		
				;Sai:   
				;		NovoBuffer -> buffer com o conteudo do arquivo
				;--------------------------------------------------------------------
 00D2				criaNovoBuffer    proc near
 00D2  8D 1E 001B R			lea bx, FileBuffer
				
 00D6				criaNovoBuffer_loop:
 00D6  8A 17				mov 	dl, [bx]	; Carrega o primeiro caractere do buffer
					
 00D8  80 FA 00				cmp 	dl, 0		; Verifica se o buffer está vazio
 00DB  74 71				je 		criaNovoBuffer_sem_start	; Se estiver, retorna
				
 00DD  80 FA 53				cmp     byte ptr dl, 'S'             ; Verifica se o caractere é 'S'
 00E0  75 69				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 00E2  8A 57 01				mov dl, [bx + 1]
				
 00E5  80 FA 54				cmp     byte ptr dl, 'T'  ; Verifica se o próximo caractere é 'T'
 00E8  75 61				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 00EA  8A 57 02				mov dl, [bx + 2]
				
 00ED  80 FA 41				cmp     byte ptr dl, 'A'; Verifica se o próximo caractere é 'A'
 00F0  75 59				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 00F2  8A 57 03				mov dl, [bx + 3]
				
 00F5  80 FA 52				cmp     byte ptr dl, 'R'; Verifica se o próximo caractere é 'R'
 00F8  75 51				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 00FA  8A 57 04				mov dl, [bx + 4]
				
 00FD  80 FA 54				cmp     byte ptr dl, 'T'; Verifica se o próximo caractere é 'T'
 0100  75 49				jne     criaNovoBuffer_end    ; Se não for, sai do loop
 0102  83 C3 04				add     bx, 4
 0105  8D 36 07EB R			lea 	si, NewBuffer
				
 0109				criaNovoBuffer_loop2:
 0109  43				inc bx
 010A  8A 17				mov 	dl, [bx]
 010C  80 FA 0A				cmp     byte ptr dl, 0Ah ; CR (Carriage Return)
 010F  74 F8				je criaNovoBuffer_loop2
 0111  80 FA 0D				cmp     byte ptr dl, 0Dh ; LF (Line Feed)
 0114  74 F3				je criaNovoBuffer_loop2
				
 0116  4B				dec bx
 0117				criaNovoBuffer_insere:
 0117  03 C6				add     ax, si
 0119  43				inc 	bx
 011A  8A 17				mov 	dl, [bx]
 011C  80 FA 00				cmp     byte ptr dl, 0 
 011F  74 43				je		criaNovoBuffer_sem_stop
				
 0121  88 14				mov 	byte ptr [si], dl
 0123  46				inc 	si
				
 0124  80 FA 53				cmp 	byte ptr dl, 'S' ; Verifica se o próximo caractere é 'S' de 'STOP'
 0127  75 EE				jne		criaNovoBuffer_insere
 0129  4E				dec si 
				
 012A  8A 57 01				mov 	dl, [bx + 1]
 012D  80 FA 54				cmp 	byte ptr dl, 'T' ; Verifica se o próximo caractere é 'T' de 'STOP'
 0130  75 E5				jne		criaNovoBuffer_insere
 0132  8A 57 02				mov 	dl, [bx + 2]
 0135  80 FA 4F				cmp 	byte ptr dl, 'O' ; Verifica se o próximo caractere é 'O' de 'STOP'
 0138  75 DD				jne		criaNovoBuffer_insere
 013A  8A 57 03				mov 	dl, [bx + 3]
 013D  80 FA 50				cmp 	byte ptr dl, 'P' ; Verifica se o próximo caractere é 'P' de 'STOP'
 0140  75 D5				jne		criaNovoBuffer_insere
 0142  83 C3 04				add 	bx, 4
				
 0145  C7 04 0000			mov     [si], 0
					
 0149  EB 11				jmp     criaNovoBuffer_print
					
 014B				criaNovoBuffer_end:
 014B  43				inc bx
 014C  EB 88				jmp criaNovoBuffer_loop
				
 014E				criaNovoBuffer_sem_start:
 014E  83 F9 00				cmp cx, 0
 0151  8D 1E 1838 R			lea bx, MsgErroSemStart
 0155  E8 00E2				call printf_s
					.exit
				
 015C				criaNovoBuffer_print:
 015C  8D 1E 07EB R			lea bx, NewBuffer
				
 0160  E8 00D7				call printf_s
 0163  C3				ret
				
 0164				criaNovoBuffer_sem_stop:
 0164  8D 1E 1871 R			lea bx, MsgErroSemStop
 0168  E8 00CF				call printf_s
					.exit
				
 016F				criaNovoBuffer    endp
				
				;--------------------------------------------------------------------
				;Função que traduz cada caracter do novo buffer em um barcode 
				;		
				;Sai:   
				;		Buffer com dados em barcode
				;--------------------------------------------------------------------
 016F				transformaEmBarcode proc near
 016F  B9 0000				mov     cx, 0
 0172  8D 36 0FBB R			lea 	si, OutputBuffer
 0176  8D 1E 07EB R			lea 	bx, NewBuffer
					
 017A  B9 000B				mov      cx, 11
 017D  E8 007F				call     transforma_em_barcode_exec
				
 0180				transformaEmBarcode_loop:
 0180  8A 17				mov     dl, [bx]
				
 0182  43				inc bx
				
 0183  80 FA 00				cmp     byte ptr dl, 0    ; Verifica se o buffer está vazio
 0186  75 03 E9 0098			je      transformaEmBarcode_fim_traducao    ; Se estiver, retorna
				
 018B  80 FA 0D				cmp 	byte ptr dl, 13
 018E  74 F0				je 		transformaEmBarcode_loop
				
 0190  80 FA 0A				cmp 	byte ptr dl, 10
 0193  74 EB				je 		transformaEmBarcode_loop
				
 0195  B9 0000				mov 	cx, 0
 0198  80 FA 30				cmp     byte ptr dl, '0'    ; Verifica se o caractere é '0'
 019B  74 5D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 019D  B9 0001				mov 	cx, 1
 01A0  80 FA 31				cmp     byte ptr dl, '1'    ; Verifica se o caractere é '1'
 01A3  74 55				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01A5  B9 0002				mov 	cx, 2
 01A8  80 FA 32				cmp     byte ptr dl, '2'    ; Verifica se o caractere é '2'
 01AB  74 4D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01AD  B9 0003				mov 	cx, 3
 01B0  80 FA 33				cmp     byte ptr dl, '3'    ; Verifica se o caractere é '3'
 01B3  74 45				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01B5  B9 0004				mov 	cx, 4
 01B8  80 FA 34				cmp     byte ptr dl, '4'    ; Verifica se o caractere é '4'
 01BB  74 3D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01BD  B9 0005				mov 	cx, 5
 01C0  80 FA 35				cmp     byte ptr dl, '5'    ; Verifica se o caractere é '5'
 01C3  74 35				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01C5  B9 0006				mov 	cx, 6
 01C8  80 FA 36				cmp     byte ptr dl, '6'    ; Verifica se o caractere é '6'
 01CB  74 2D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01CD  B9 0007				mov 	cx, 7
 01D0  80 FA 37				cmp     byte ptr dl, '7'    ; Verifica se o caractere é '7'
 01D3  74 25				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01D5  B9 0008				mov 	cx, 8
 01D8  80 FA 38				cmp     byte ptr dl, '8'    ; Verifica se o caractere é '8'
 01DB  74 1D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01DD  B9 0009				mov 	cx, 9
 01E0  80 FA 39				cmp     byte ptr dl, '9'    ; Verifica se o caractere é '9'
 01E3  74 15				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01E5  B9 000A				mov 	cx, 10
 01E8  80 FA 2D				cmp     byte ptr dl, '-'    ; Verifica se o caractere é '-'
 01EB  74 0D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01ED  EB 00				jmp     transformaEmBarcode_erro_caractere_invalido
				
 01EF				transformaEmBarcode_erro_caractere_invalido:
 01EF  8D 1E 18DE R			lea     bx, MsgErrorCaracterInvalido
 01F3  E8 0044				call    printf_s
					.exit
				
 01FA				transformaEmBarcode_codigo:
 01FA  E8 0002				call transforma_em_barcode_exec
 01FD  EB 81				jmp transformaEmBarcode_loop
				
 01FF				transforma_em_barcode_exec:
 01FF  53				push 	bx
 0200  8D 1E 178B R			lea 	bx, BarCodeTable
 0204  03 D9				add 	bx, cx
 0206  8A 17				mov 	dl, [bx]
					
 0208				loop_acha_primeiro_0:
 0208  D0 E2				shl	 dl, 1
 020A  72 02				jc loop_coloca_valores_0
 020C  EB FA				jmp loop_acha_primeiro_0
				
 020E				loop_coloca_valores_0:
 020E  B8 0030				mov  ax, 30h
 0211  83 D0 00				adc  ax, 0
				
 0214  89 04				mov	 [si], ax
 0216  41				inc cx
 0217  46				inc si
				
 0218  80 FA 00				cmp 	dl, 0
 021B  74 04				je  	loop_coloca_valores_0_acaba
				
 021D  D0 E2				shl 	dl, 1
 021F  EB ED				jmp 	loop_coloca_valores_0
				
 0221				loop_coloca_valores_0_acaba:
 0221  5B				pop 	bx
 0222  C3				ret
				
 0223				transformaEmBarcode_fim_traducao:
 0223  B9 000B				mov      cx, 11
 0226  E8 FFD6				call transforma_em_barcode_exec
				
 0229  C3			    ret
				
				
 022A				transformaEmBarcode endp
				
				;--------------------------------------------------------------------
				;Entra: BX -> file handle
				;       dl -> caractere
				;Sai:   AX -> numero de caracteres escritos
				;		CF -> "0" se escrita ok
				;--------------------------------------------------------------------
 022A				setChar	proc	near
 022A  B4 40				mov		ah,40h
 022C  B9 0001				mov		cx,1
 022F  88 16 001B R			mov		FileBuffer,dl
 0233  8D 16 001B R			lea		dx,FileBuffer
 0237  CD 21				int		21h
 0239  C3				ret
 023A				setChar	endp	
				
				
				;--------------------------------------------------------------------
				;Função Escrever um string na tela
				;		printf_s(char *s -> BX)
				;--------------------------------------------------------------------
 023A				printf_s	proc	near
 023A  8A 17				mov		dl,[bx]
 023C  80 FA 00				cmp		dl,0
 023F  74 09				je		ps_1
				
 0241  53				push	bx
 0242  B4 02				mov		ah,2
 0244  CD 21				int		21H
 0246  5B				pop		bx
				
 0247  43				inc		bx		
 0248  EB F0				jmp		printf_s
				
 024A				ps_1:
 024A  C3				ret
 024B				printf_s	endp
				
				;--------------------------------------------------------------------
						end
				;--------------------------------------------------------------------
				
				
					
				
				

Microsoft (R) Macro Assembler Version 6.11		    12/23/24 23:35:33
main.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 1928	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 024B	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

criaNovoBuffer . . . . . . . . .	P Near	 00D2	  _TEXT	Length= 011E Private
fclose . . . . . . . . . . . . .	P Near	 00B6	  _TEXT	Length= 0005 Private
fcreate  . . . . . . . . . . . .	P Near	 00AC	  _TEXT	Length= 000A Private
fopen  . . . . . . . . . . . . .	P Near	 00A3	  _TEXT	Length= 0009 Private
getChar  . . . . . . . . . . . .	P Near	 00BB	  _TEXT	Length= 0017 Private
printf_s . . . . . . . . . . . .	P Near	 023A	  _TEXT	Length= 0011 Private
setChar  . . . . . . . . . . . .	P Near	 022A	  _TEXT	Length= 0010 Private
transformaEmBarcode  . . . . . .	P Near	 016F	  _TEXT	Length= 00BB Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
BarCodeTable . . . . . . . . . .	Byte	 178B	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
ContadorBuffer . . . . . . . . .	Word	 0000	  _DATA	
Continua1  . . . . . . . . . . .	L Near	 0030	  _TEXT	
Continua2  . . . . . . . . . . .	L Near	 0050	  _TEXT	
Continua3  . . . . . . . . . . .	L Near	 0073	  _TEXT	
Continua4  . . . . . . . . . . .	L Near	 007A	  _TEXT	
FileBuffer . . . . . . . . . . .	Byte	 001B	  _DATA	
FileHandleDst  . . . . . . . . .	Word	 0019	  _DATA	
FileHandleSrc  . . . . . . . . .	Word	 0017	  _DATA	
FileNameDst  . . . . . . . . . .	Byte	 000F	  _DATA	
FileNameSrc  . . . . . . . . . .	Byte	 0008	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
MsgErroCreateFile  . . . . . . .	Byte	 17CD	  _DATA	
MsgErroOpenFile  . . . . . . . .	Byte	 1797	  _DATA	
MsgErroReadFile  . . . . . . . .	Byte	 1802	  _DATA	
MsgErroSemStart  . . . . . . . .	Byte	 1838	  _DATA	
MsgErroSemStop . . . . . . . . .	Byte	 1871	  _DATA	
MsgErroWriteFile . . . . . . . .	Byte	 18A9	  _DATA	
MsgErrorCaracterInvalido . . . .	Byte	 18DE	  _DATA	
NewBuffer  . . . . . . . . . . .	Byte	 07EB	  _DATA	
NomeTesteAleatorio . . . . . . .	Byte	 0002	  _DATA	
OutputBuffer . . . . . . . . . .	Byte	 0FBB	  _DATA	
TerminouArquivo  . . . . . . . .	L Near	 0083	  _TEXT	
criaNovoBuffer_end . . . . . . .	L Near	 014B	  _TEXT	
criaNovoBuffer_insere  . . . . .	L Near	 0117	  _TEXT	
criaNovoBuffer_loop2 . . . . . .	L Near	 0109	  _TEXT	
criaNovoBuffer_loop  . . . . . .	L Near	 00D6	  _TEXT	
criaNovoBuffer_print . . . . . .	L Near	 015C	  _TEXT	
criaNovoBuffer_sem_start . . . .	L Near	 014E	  _TEXT	
criaNovoBuffer_sem_stop  . . . .	L Near	 0164	  _TEXT	
loop_acha_primeiro_0 . . . . . .	L Near	 0208	  _TEXT	
loop_coloca_valores_0_acaba  . .	L Near	 0221	  _TEXT	
loop_coloca_valores_0  . . . . .	L Near	 020E	  _TEXT	
ps_1 . . . . . . . . . . . . . .	L Near	 024A	  _TEXT	
transformaEmBarcode_codigo . . .	L Near	 01FA	  _TEXT	
transformaEmBarcode_erro_caractere_invalido  L Near   01EF     _TEXT	
transformaEmBarcode_fim_traducao .	L Near	 0223	  _TEXT	
transformaEmBarcode_loop . . . .	L Near	 0180	  _TEXT	
transforma_em_barcode_exec . . .	L Near	 01FF	  _TEXT	

	   0 Warnings
	   0 Errors
