Microsoft (R) Macro Assembler Version 6.11		    01/07/25 17:44:05
main.asm						     Page 1 - 1


				;
				;====================================================================
				;	- Escrever um programa para ler um arquivo texto e 
				;		apresentá-lo na tela
				;	- O usuário devem informar o nome do arquivo, 
				;		assim que for apresentada a mensagem: Nome do arquivo: 
				;====================================================================
				;
					.model		small
					.stack
						
 = 000D				CR		equ		0dh
 = 000A				LF		equ		0ah

 0000					.data
 0000 53 54 41 52 54 00		PalavraStart 	db 		"START", 0
 0006 53 54 4F 50 00		PalavraStop 	db 		"STOP", 0
 000B 0000			ContadorBuffer  dw 	0
 000D 4E 6F 6D 65 20 64		NomeArquivoEntrada	db		"Nome do arquivo: ", 0
       6F 20 61 72 71 75
       69 76 6F 3A 20 00
 001F 4E 6F 6D 65 20 64		NomeArquivoSaida	db		"Nome do arquivo de saida: ", 0
       6F 20 61 72 71 75
       69 76 6F 20 64 65
       20 73 61 69 64 61
       3A 20 00
 003A 49 4E 2E 74 78 74		FileNameSrc		db		"IN.txt", 0		; Nome do arquivo a ser lido
       00
 0041 4F 55 54 2E 62 61		FileNameDst		db		"OUT.bar", 0	; Nome do arquivo a ser escrito
       72 00
 0049 0000			FileHandleSrc	dw		0				; Handler do arquivo origem
 004B 0000			FileHandleDst	dw		0				; Handler do arquivo destino
 004D  07D0 [			FileBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 081D  07D0 [			NewBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 0FED  07D0 [			OutputBuffer    db 		2000 dup(?) 	; Espaço para os BarCodes (64 bytes)
        00
       ]

 17BD 000A			Divisor10 		dw 		10
 17BF  07D0 [			ChecksumBuffer 	db 		2000 dup(?) 	; Espaço para os Checksums (64 bytes)
        00
       ]
 1F8F 00			Pesochecksum 	db		0
 1F90 0000			ChecksumTotal   dw 		0
 1F92 0000			Checksum 		dw		0
 1F94 01			ColocaSeparador	db		1
 1F95 0D 0A 00			MsgNewLine          db CR, LF, 0 ; Caractere para nova linha

 1F98 2B			BarCodeTable DB 101011b     ; 0
 1F99  6B				DB 1101011b    ; 1
 1F9A  4B				DB 1001011b    ; 2
 1F9B  65				DB 1100101b    ; 3
 1F9C  5B				DB 1011011b    ; 4
 1F9D  6D				DB 1101101b    ; 5
 1F9E  4D				DB 1001101b    ; 6
 1F9F  53				DB 1010011b    ; 7
 1FA0  69				DB 1101001b    ; 8
 1FA1  35				DB 110101b    ; 9
 1FA2  2D				DB 101101b     ; -
 1FA3  59				DB 1011001b    ; SS

				; Mensagens de erros que podem aparecer na execucao do programa
 1FA4 45 72 72 6F 3A 20		MsgErroOpenFile		db	"Erro: Nao foi possivel fazer a abertura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 61 62 65 72 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 1FDA 45 72 72 6F 3A 20		MsgErroCreateFile	db	"Erro: Nao foi possivel fazer a criacao do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 63 72 69 61 63
       61 6F 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 200F 45 72 72 6F 3A 20		MsgErroReadFile		db	"Erro: Nao foi possível fazer a leitura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       C3 AD 76 65 6C 20
       66 61 7A 65 72 20
       61 20 6C 65 69 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 2045 45 72 72 6F 3A 20		MsgErroSemStart		db	"Erro: Nao foi encontrado a palavra 'START' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 41 52 54 27
       20 6E 6F 20 61 72
       71 75 69 76 6F 2E
       0D 0A 00
 207E 45 72 72 6F 3A 20		MsgErroSemStop		db	"Erro: Nao foi encontrado a palavra 'STOP' apos a palavra 'START' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 4F 50 27 20
       61 70 6F 73 20 61
       20 70 61 6C 61 76
       72 61 20 27 53 54
       41 52 54 27 20 6E
       6F 20 61 72 71 75
       69 76 6F 2E 0D 0A
       00
 20CD 45 72 72 6F 3A 20		MsgErroWriteFile	db	"Erro: Nao foi possivel fazer a escrita do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 65 73 63 72 69
       74 61 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
				; Mensagens de erros que podem aparecer no arquivo de texto final
 2102 45 72 72 6F 3A 20		MsgErrorCaracterInvalido db "Erro: Nao foi possivel fazer a traducao de um caracter que eh invalido.", 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 74 72 61 64 75
       63 61 6F 20 64 65
       20 75 6D 20 63 61
       72 61 63 74 65 72
       20 71 75 65 20 65
       68 20 69 6E 76 61
       6C 69 64 6F 2E 00
 214A 45 72 72 6F 3A 20		MsgLinhaEmBranco	db 	"Erro: Nao foi possivel fazer a traducao de uma linha em branco.", 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 74 72 61 64 75
       63 61 6F 20 64 65
       20 75 6D 61 20 6C
       69 6E 68 61 20 65
       6D 20 62 72 61 6E
       63 6F 2E 00
 218A 45 72 72 6F 3A 20		MsgTamanhoInvalido 	db 	"Erro: Nao foi possivel fazer a traducao de uma linha com mais de 10 caracteres.", 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 74 72 61 64 75
       63 61 6F 20 64 65
       20 75 6D 61 20 6C
       69 6E 68 61 20 63
       6F 6D 20 6D 61 69
       73 20 64 65 20 31
       30 20 63 61 72 61
       63 74 65 72 65 73
       2E 00

 0000				.code
				.startup
					; Abro o meu arquivo de entrada, se ele não existir, eu exibo uma mensagem de erro e encerro o programa
 0017  8D 16 003A R			lea		dx,FileNameSrc
 001B  E8 011E				call	fopen
 001E  89 1E 0049 R			mov		FileHandleSrc,bx
 0022  73 0C				jnc		criarArquivoSaida ; Se não der nenhum problema, vou para a proxima etapa
 0024  8D 1E 1FA4 R			lea		bx, MsgErroOpenFile
 0028  E8 03FE				call	printf_s
					.exit	1
 0030				criarArquivoSaida:
					; Criando o arquivo de destino, que será o arquivo de saída, caso ele já exista, ele será sobrescrito. Se eu não conseguir
					; criar o arquivo de destino, eu fecho o arquivo de origem e exibo uma mensagem de erro
 0030  8D 16 0041 R			lea		dx,FileNameDst
 0034  E8 010E				call	fcreate
 0037  89 1E 004B R			mov		FileHandleDst,bx
 003B  73 13				jnc		lerArquivoDeEntrada
 003D  8B 1E 0049 R			mov		bx,FileHandleSrc
 0041  E8 010B				call	fclose
 0044  8D 1E 1FDA R			lea		bx, MsgErroCreateFile
 0048  E8 03DE				call	printf_s
					.exit	1
 0050				lerArquivoDeEntrada:
					; Leio o arquivo de entrada, se eu não conseguir ler o arquivo de entrada, eu fecho os arquivos e exibo uma mensagem de erro
 0050  8B 1E 0049 R			mov		bx,FileHandleSrc    
 0054  E8 00FD				call	getChar
 0057  73 1A				jnc		leituraCorretaArquivoEntrada
 0059  8D 1E 200F R			lea		bx, MsgErroReadFile
 005D  E8 03C9				call	printf_s
 0060  8B 1E 0049 R			mov		bx,FileHandleSrc
 0064  E8 00E8				call	fclose
 0067  8B 1E 004B R			mov		bx,FileHandleDst
 006B  E8 00E1				call	fclose
					.exit	1
 0073				leituraCorretaArquivoEntrada:
 0073  83 F8 00				cmp		ax,0
 0076  74 02				jz		terminouLerArquivoEntrada
 0078  EB D6				jmp 	lerArquivoDeEntrada
					
 007A				terminouLerArquivoEntrada:
					; Criando um novo buffer a partir dos dados do arquivo de entrada pois eu só quero o conteudo entre o START e o STOP
 007A  8D 1E 000D R			lea 	bx, NomeArquivoEntrada
 007E  E8 03A8				call 	printf_s
 0081  8D 1E 003A R			lea 	bx, FileNameSrc
 0085  E8 03A1				call 	printf_s
 0088  8D 1E 1F95 R			lea 	bx, MsgNewLine	
 008C  E8 039A				call 	printf_s
 008F  E8 00D9				call    criaNovoBuffer

 0092  8D 36 0FED R			lea 	si, OutputBuffer
 0096  8D 1E 081D R			lea 	bx, NewBuffer

 009A				loop_transformacoes:
					; Loop responsável por transformar cada caractere do buffer em um barcode
 009A  E8 0171				call    transformaEmBarcode

					; Adiciona um CR e um LF no final de cada barcode
 009D  C7 04 000D			mov 	[si], 13
 00A1  46				inc 	si
 00A2  C7 04 000A			mov 	[si], 10
 00A6  46				inc 	si

 00A7  4B				dec 	bx
 00A8  80 3F 0D				cmp 	byte ptr [bx], 13
 00AB  74 03				je 		incrementa_bx

 00AD  43				inc 	bx
 00AE  EB 05				jmp 	checagem_fim_arquivo

 00B0				incrementa_bx:	
 00B0  83 C3 02				add bx, 2
 00B3  EB 00				jmp checagem_fim_arquivo

 00B5				checagem_fim_arquivo:
					; Verifica se já chegamos no final do buffer de conteudo entre START e STOP
 00B5  80 3F 00				cmp 	byte ptr [bx], 0
 00B8  75 E0				jne 	loop_transformacoes

					; Escreve o conteudo do buffer de barcode no arquivo de destino
 00BA  8D 36 0FED R			lea 	si, OutputBuffer
 00BE  8B 1E 004B R			mov 	bx, FileHandleDst
 00C2  B9 0000				mov 	cx, 0

 00C5				loop_escreve_START_arquivo_saida:
 00C5  56				push 	si
 00C6  8D 36 0000 R			lea 	si, PalavraStart
 00CA				loop_escreve_start:
					; Escreve START no início do arquivo de saída
 00CA  8A 14				mov 	dl, [si]
 00CC  80 FA 00				cmp 	byte ptr dl, 0
 00CF  74 08				je      escreve_cr_lf
 00D1  53				push 	bx
 00D2  E8 0344				call 	setChar
 00D5  5B				pop 	bx
 00D6  46				inc 	si
 00D7  EB F1				jmp 	loop_escreve_start

 00D9				escreve_cr_lf:
 00D9  B2 0D				mov 	dl, 13
 00DB  53				push 	bx
 00DC  E8 033A				call 	setChar
 00DF  5B				pop bx

 00E0  B2 0A				mov 	dl, 10
 00E2  53				push 	bx
 00E3  E8 0333				call 	setChar
 00E6  5B				pop     bx
 00E7  5E				pop 	si
 00E8  EB 00				jmp loop_escrever_output


 00EA				loop_escrever_output:
 00EA  8A 14				mov 	dl, [si]
 00EC  80 FA 00				cmp 	byte ptr dl, 0
 00EF  74 08				je 		loop_escrever_STOP

					; Coloca os valores no arquivo de destino
 00F1  53				push 	bx
 00F2  E8 0324				call 	setChar
 00F5  5B				pop 	bx
 00F6				final_loop_escrever_output:
 00F6  46				inc 	si
 00F7  EB F1				jmp 	loop_escrever_output
					
 00F9				loop_escrever_STOP:
 00F9  56				push 	si
 00FA  8D 36 0006 R			lea 	si, PalavraStop
 00FE				loop_escreve_stop:
					; Escreve a palavra STOP no final do arquivo de saida
 00FE  8A 14				mov 	dl, [si]
 0100  80 FA 00				cmp 	byte ptr dl, 0
 0103  74 08				je      loop_escrever_output_fim
 0105  53				push 	bx
 0106  E8 0310				call 	setChar
 0109  5B				pop 	bx
 010A  46				inc 	si
 010B  EB F1				jmp 	loop_escreve_stop

 010D				loop_escrever_output_fim:
					; Printa o conteudo do arquivo de saida ( Sem o START e sem o STOP ) no terminal
 010D  8D 1E 001F R			lea 	bx, NomeArquivoSaida
 0111  E8 0315				call 	printf_s
 0114  8D 1E 0041 R			lea 	bx, FileNameDst
 0118  E8 030E				call 	printf_s
 011B  8D 1E 1F95 R			lea 	bx, MsgNewLine
 011F  E8 0307				call 	printf_s
 0122  8D 1E 0FED R			lea 	bx, OutputBuffer
 0126  E8 0300				call 	printf_s

					; Fecha os arquivos após terminar de escrever tudo no arquivo de saída.
 0129  8B 1E 0049 R			mov		bx,FileHandleSrc	; Fecha arquivo origem
 012D  E8 001F				call	fclose
 0130  8B 1E 004B R			mov		bx,FileHandleDst	; Fecha arquivo destino
 0134  E8 0018				call	fclose
					.exit	0


				;--------------------------------------------------------------------
				;Função	Abre o arquivo cujo nome está no string apontado por DX
				;		boolean fopen(char *FileName -> DX)
				;Entra: DX -> ponteiro para o string com o nome do arquivo
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 013C				fopen	proc	near
 013C  B0 00				mov		al,0
 013E  B4 3D				mov		ah,3dh
 0140  CD 21				int		21h
 0142  8B D8				mov		bx,ax
 0144  C3				ret
 0145				fopen	endp

				;--------------------------------------------------------------------
				;Função Cria o arquivo cujo nome está no string apontado por DX
				;		boolean fcreate(char *FileName -> DX)
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 0145				fcreate	proc	near
 0145  B9 0000				mov		cx,0
 0148  B4 3C				mov		ah,3ch
 014A  CD 21				int		21h
 014C  8B D8				mov		bx,ax
 014E  C3				ret
 014F				fcreate	endp

				;--------------------------------------------------------------------
				;Entra:	BX -> file handle
				;Sai:	CF -> "0" se OK
				;--------------------------------------------------------------------
 014F				fclose	proc	near
 014F  B4 3E				mov		ah,3eh
 0151  CD 21				int		21h
 0153  C3				ret
 0154				fclose	endp

				;--------------------------------------------------------------------
				;Função	Le um caractere do arquivo identificado pelo HANLDE BX
				;		getChar(handle->BX)
				;Entra: BX -> file handle
				;Sai:   
				;		AX -> numero de caracteres lidos
				;		CF -> "0" se leitura ok
				;--------------------------------------------------------------------
 0154				getChar proc near
 0154  B9 0001			    mov     cx, 1                  ; Number of bytes to read
 0157  8D 36 004D R		    lea     si, FileBuffer         ; Load the base address of FileBuffer into SI
 015B  8B D6			    mov     dx, si                 ; Copy base address to DX (used by DOS)
 015D  A1 000B R		    mov     ax, ContadorBuffer     ; Load FileCounter into AX
 0160  03 D0			    add     dx, ax                 ; Adjust DX to point to the current position
 0162  B4 3F			    mov     ah, 3Fh                ; DOS function: Read from file
 0164  CD 21			    int     21h                    ; Call DOS interrupt
 0166  FF 06 000B R		    inc     ContadorBuffer         ; Increment the counter for the next read
 016A  C3			    ret                            ; Return to the caller
 016B				getChar endp

				;--------------------------------------------------------------------
				;Função que cria um novo buffer com o conteudo do arquivo que interessa
				;		
				;Sai:   
				;		NovoBuffer -> buffer com o conteudo do arquivo
				;--------------------------------------------------------------------
 016B				criaNovoBuffer    proc near
 016B  8D 1E 004D R			lea 	bx, FileBuffer

 016F				criaNovoBuffer_loop:
 016F  8A 17				mov 	dl, [bx]	; Carrega o primeiro caractere do buffer
					
 0171  80 FA 00				cmp 	dl, 0		; Verifica se o buffer está vazio
 0174  74 77				je 		criaNovoBuffer_sem_start	; Se estiver, retorna

 0176  80 FA 53				cmp     byte ptr dl, 'S'             ; Verifica se o caractere é 'S'
 0179  75 6F				jne     criaNovoBuffer_end    ; Se não for, sai do loop

 017B  8A 57 01				mov 	dl, [bx + 1]

 017E  80 FA 54				cmp     byte ptr dl, 'T'  ; Verifica se o próximo caractere é 'T'
 0181  75 67				jne     criaNovoBuffer_end    ; Se não for, sai do loop

 0183  8A 57 02				mov 	dl, [bx + 2]

 0186  80 FA 41				cmp     byte ptr dl, 'A'; Verifica se o próximo caractere é 'A'
 0189  75 5F				jne     criaNovoBuffer_end    ; Se não for, sai do loop

 018B  8A 57 03				mov 	dl, [bx + 3]

 018E  80 FA 52				cmp     byte ptr dl, 'R'; Verifica se o próximo caractere é 'R'
 0191  75 57				jne     criaNovoBuffer_end    ; Se não for, sai do loop

 0193  8A 57 04				mov 	dl, [bx + 4]

 0196  80 FA 54				cmp     byte ptr dl, 'T'; Verifica se o próximo caractere é 'T'
 0199  75 4F				jne     criaNovoBuffer_end    ; Se não for, sai do loop
 019B  83 C3 04				add     bx, 4
 019E  8D 36 081D R			lea 	si, NewBuffer
					
 01A2  80 7F 01 0A			cmp 	byte ptr [bx + 1], 10
 01A6  74 0B				je 		criaNovoBuffer_loop2
 01A8  80 7F 01 0D			cmp 	byte ptr [bx + 1], 13
 01AC  74 02				je 		incrementa_bx_start_2

 01AE  EB 03				jmp 	criaNovoBuffer_loop2 

 01B0				incrementa_bx_start_2:
 01B0  83 C3 01				add 	bx, 1

 01B3				criaNovoBuffer_loop2:
 01B3  43				inc 	bx
 01B4  8A 17				mov 	dl, [bx]
 01B6				criaNovoBuffer_insere:
 01B6  03 C6				add     ax, si
 01B8  43				inc 	bx
 01B9  8A 17				mov 	dl, [bx]
 01BB  80 FA 00				cmp     byte ptr dl, 0 
 01BE  74 43				je		criaNovoBuffer_sem_stop

 01C0  88 14				mov 	byte ptr [si], dl
 01C2  46				inc 	si

 01C3  80 FA 53				cmp 	byte ptr dl, 'S' ; Verifica se o próximo caractere é 'S' de 'STOP'
 01C6  75 EE				jne		criaNovoBuffer_insere
 01C8  4E				dec 	si 

 01C9  8A 57 01				mov 	dl, [bx + 1]
 01CC  80 FA 54				cmp 	byte ptr dl, 'T' ; Verifica se o próximo caractere é 'T' de 'STOP'
 01CF  75 E5				jne		criaNovoBuffer_insere
 01D1  8A 57 02				mov 	dl, [bx + 2]
 01D4  80 FA 4F				cmp 	byte ptr dl, 'O' ; Verifica se o próximo caractere é 'O' de 'STOP'
 01D7  75 DD				jne		criaNovoBuffer_insere
 01D9  8A 57 03				mov 	dl, [bx + 3]
 01DC  80 FA 50				cmp 	byte ptr dl, 'P' ; Verifica se o próximo caractere é 'P' de 'STOP'
 01DF  75 D5				jne		criaNovoBuffer_insere
 01E1  83 C3 04				add 	bx, 4

 01E4  C7 04 0000			mov     [si], 0
					
 01E8  EB 11				jmp     criaNovoBuffer_print
					
 01EA				criaNovoBuffer_end:
 01EA  43				inc 	bx
 01EB  EB 82				jmp 	criaNovoBuffer_loop

 01ED				criaNovoBuffer_sem_start:
 01ED  83 F9 00				cmp 	cx, 0
 01F0  8D 1E 2045 R			lea 	bx, MsgErroSemStart
 01F4  E8 0232				call 	printf_s
					.exit

 01FB				criaNovoBuffer_print:
 01FB  8D 1E 081D R			lea 	bx, NewBuffer

 01FF  E8 0227				call 	printf_s
 0202  C3				ret

 0203				criaNovoBuffer_sem_stop:
 0203  8D 1E 207E R			lea 	bx, MsgErroSemStop
 0207  E8 021F				call 	printf_s
					.exit

 020E				criaNovoBuffer    endp

				;--------------------------------------------------------------------
				;Função que traduz cada caracter do novo buffer em um barcode 
				;		
				;Sai:   
				;		Buffer com dados em barcode
				;--------------------------------------------------------------------
 020E				transformaEmBarcode proc near
 020E  B9 000B				mov     cx, 11
 0211  E8 00B3				call    transforma_em_barcode_exec

 0214  8C DA				mov 	dx, ds
 0216  8E C2				mov 	es, dx
 0218  BF 0000				mov 	di, 0
 021B  8D 3E 17BF R			lea 	di, ChecksumBuffer
 021F  33 C0			    xor     ax, ax                ; Zera AX para evitar resíduos

 0221  C7 04 0030			mov 	[si], '0'
 0225  46				inc 	si

 0226				transformaEmBarcode_loop:
 0226  8A 17				mov     dl, [bx]
 0228  88 15				mov 	[di], dl
 022A  43				inc 	bx
 022B  47				inc 	di

 022C  80 FA 00				cmp     byte ptr dl, 0    ; Verifica se o buffer está vazio
 022F  75 03 E9 00D2			je      transformaEmBarcode_fim_traducao    ; Se estiver, retorna

 0234  80 FA 0D				cmp 	byte ptr dl, 13
 0237  75 03 E9 00CA			je 		transformaEmBarcode_fim_traducao

 023C  80 FA 0A				cmp 	byte ptr dl, 10
 023F  75 03 E9 00C2			je 		transformaEmBarcode_fim_traducao

 0244  B9 0000				mov 	cx, 0
 0247  80 FA 30				cmp     byte ptr dl, '0'    ; Verifica se o caractere é '0'
 024A  74 75				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 024C  B9 0001				mov 	cx, 1
 024F  80 FA 31				cmp     byte ptr dl, '1'    ; Verifica se o caractere é '1'
 0252  74 6D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 0254  B9 0002				mov 	cx, 2
 0257  80 FA 32				cmp     byte ptr dl, '2'    ; Verifica se o caractere é '2'
 025A  74 65				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 025C  B9 0003				mov 	cx, 3
 025F  80 FA 33				cmp     byte ptr dl, '3'    ; Verifica se o caractere é '3'
 0262  74 5D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 0264  B9 0004				mov 	cx, 4
 0267  80 FA 34				cmp     byte ptr dl, '4'    ; Verifica se o caractere é '4'
 026A  74 55				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 026C  B9 0005				mov 	cx, 5
 026F  80 FA 35				cmp     byte ptr dl, '5'    ; Verifica se o caractere é '5'
 0272  74 4D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 0274  B9 0006				mov 	cx, 6
 0277  80 FA 36				cmp     byte ptr dl, '6'    ; Verifica se o caractere é '6'
 027A  74 45				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 027C  B9 0007				mov 	cx, 7
 027F  80 FA 37				cmp     byte ptr dl, '7'    ; Verifica se o caractere é '7'
 0282  74 3D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 0284  B9 0008				mov 	cx, 8
 0287  80 FA 38				cmp     byte ptr dl, '8'    ; Verifica se o caractere é '8'
 028A  74 35				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 028C  B9 0009				mov 	cx, 9
 028F  80 FA 39				cmp     byte ptr dl, '9'    ; Verifica se o caractere é '9'
 0292  74 2D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 0294  B9 000A				mov 	cx, 10
 0297  80 FA 2D				cmp     byte ptr dl, '-'    ; Verifica se o caractere é '-'
 029A  74 25				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode

 029C  EB 00				jmp     transformaEmBarcode_erro_caractere_invalido

 029E				transformaEmBarcode_erro_caractere_invalido:
 029E				loop_volta_inicio_linha:

 029E  83 EE 01				sub 	si, 1
 02A1  8A 14				mov 	dl, [si]

 02A3  80 FA 00			    cmp 	dl, 0
 02A6  75 03 E9 012B		    je  	erro_caracter_invalido

 02AB  80 FA 0A				cmp 	dl, 10
 02AE  75 03 E9 0123			je 		erro_caracter_invalido

 02B3  80 FA 0D				cmp 	dl, 13
 02B6  75 03 E9 011B			je 		erro_caracter_invalido

 02BB  C7 04 0000			mov 	[si], 0

 02BF  EB DD				jmp 	loop_volta_inicio_linha

 02C1				transformaEmBarcode_codigo:
 02C1  E8 0003				call 	transforma_em_barcode_exec
 02C4  E9 FF5F				jmp 	transformaEmBarcode_loop

 02C7				transforma_em_barcode_exec:
 02C7  53				push 	bx
 02C8  8D 1E 1F98 R			lea 	bx, BarCodeTable
 02CC  03 D9				add 	bx, cx
 02CE  8A 17				mov 	dl, [bx]
 02D0  5B				pop 	bx
 02D1				loop_acha_primeiro:
 02D1  D0 E2				shl		dl, 1
 02D3  72 02				jc 		loop_coloca_valores
 02D5  EB FA				jmp 	loop_acha_primeiro

 02D7				loop_coloca_valores:
 02D7  B8 0030				mov  	ax, 30h
 02DA  83 D0 00				adc  	ax, 0

 02DD  89 04				mov	 	[si], ax
 02DF  46				inc 	si

 02E0  80 FA 00				cmp 	dl, 0
 02E3  74 04				je  	loop_coloca_valores_acaba

 02E5  D0 E2				shl 	dl, 1
 02E7  EB EE				jmp 	loop_coloca_valores

 02E9				loop_coloca_valores_acaba:
					
 02E9  83 F9 0A				cmp 	cx, 10
 02EC  7F 17				jg 		loop_coloca_valores_acaba_final
 02EE  53				push 	bx
 02EF  52				push 	dx
 02F0  8A 17				mov 	dl, [bx]

 02F2  80 3E 1F94 R 00			cmp 	ColocaSeparador, 0
 02F7  74 0A				je  	pula_coloca_zero

 02F9  80 FA 00				cmp     byte ptr dl, 0    ; Verifica se o buffer está vazio
 02FC  74 05				je      pula_coloca_zero    ; Se estiver, retorna
					
 02FE  C7 04 0030			mov 	[si], '0'
 0302  46				inc 	si
 0303				pula_coloca_zero:
 0303  5A				pop 	dx
 0304  5B				pop 	bx
					
 0305				loop_coloca_valores_acaba_final:
 0305  C3				ret

 0306				transformaEmBarcode_fim_traducao: 
 0306  83 F9 0B			    cmp 	cx, 11
 0309  75 03 E9 00B9			je      erro_linha_vazia_fim	
 030E  C6 05 00			    mov     byte ptr [di], 0      ; Adiciona terminador null no final do ChecksumBuffer
 0311  51			    push    cx                    ; Salva CX
 0312  53			    push    bx
 0313  57			    push    di
 0314  56			    push    si
 0315  50			    push    ax

				    ; Calcula o comprimento da palavra
 0316  B1 00			    mov     cl, 0                 ; Zera CL (contador de caracteres)
 0318  8D 3E 17BF R		    lea     di, ChecksumBuffer    ; Ponteiro para o início do buffer

 031C				loop_conta_palavras_checksum:
 031C  80 3D 0A			    cmp     byte ptr [di], 10      ; Verifica o final da palavra
 031F  74 0A			    je      loop_conta_palavras_end
 0321  80 3D 0D				cmp 	byte ptr [di], 13
 0324  74 05				je 		loop_conta_palavras_end
 0326  47			    inc     di                    ; Avança para o próximo caractere
 0327  FE C1			    inc     cl                    ; Incrementa o comprimento
 0329  EB F1			    jmp     loop_conta_palavras_checksum

 032B				loop_conta_palavras_end:
 032B  88 0E 1F8F R		    mov     Pesochecksum, cl      ; Define o peso inicial como o comprimento da palavra
 032F  80 3E 1F8F R 00		    cmp     Pesochecksum, 0
 0334  75 03 E9 0089		    jz      erro_linha_vazia

 0339  80 3E 1F8F R 0A			cmp 	Pesochecksum, 10
 033E  77 66				ja 		erro_tamanho_invalido

 0340  8D 36 17BF R		    lea     si, ChecksumBuffer    ; Ponteiro para o início do buffer
 0344  80 3C 0D				cmp 	byte ptr [si], 13
 0347  74 02				je 		incrementa_si
 0349  EB 01				jmp 	zerar_checksum
 034B				incrementa_si:
 034B  46				inc si

 034C				zerar_checksum:
 034C  C7 06 1F90 R 0000	    mov     ChecksumTotal, 0      ; Zera o ChecksumTotal
 0352				loop_calcula_checksum:
 0352  8A 04			    mov     al, [si]              ; Carrega o próximo byte do ChecksumBuffer em AL
 0354  3C 00			    cmp     al, 0                 ; Verifica se chegou ao final do buffer
 0356  74 28			    je      checksum_done

				    ; Ignora caracteres indesejados (CR e LF)
 0358  3C 0D			    cmp     al, 0Dh               ; CR
 035A  74 18			    je      ignora_caractere
 035C  3C 0A			    cmp     al, 0Ah               ; LF
 035E  74 14			    je      ignora_caractere

				    ; Converte o caractere numérico de ASCII para número
 0360  3C 2D				cmp 	al, '-'
 0362  74 04				je		coloca_valor_correto_travessao
 0364  2C 30			    sub     al, '0'               ; Converte de ASCII para número
 0366  EB 02				jmp 	nao_eh_travessao

 0368				coloca_valor_correto_travessao:
 0368  B0 0A				mov 	al, 10

 036A				nao_eh_travessao:
 036A  B4 00			    mov     ah, 0                 ; Garante que AH está zerado
 036C  F6 26 1F8F R		    mul     Pesochecksum          ; Multiplica pelo peso

				    ; Soma ao total do checksum
 0370  01 06 1F90 R		    add     ChecksumTotal, ax

 0374				ignora_caractere:
				    ; Ignora o caractere e avança no buffer
 0374  46			    inc     si                    ; Avança para o próximo caractere
 0375  FE 0E 1F8F R		    dec     Pesochecksum          ; Reduz o peso
 0379  80 3E 1F8F R 00		    cmp     Pesochecksum, 0
 037E  75 D2			    jnz     loop_calcula_checksum

 0380				checksum_done:
				    ; Salva registradores na pilha
 0380  50			    push    ax
 0381  53			    push    bx
 0382  51			    push    cx
 0383  52			    push    dx

				    ; Calcula o resto da divisão do ChecksumTotal por 11
 0384  A1 1F90 R		    mov     ax, ChecksumTotal      ; Carrega o ChecksumTotal em AX
 0387  B3 0B			    mov     bl, 11                 ; Define o divisor como 11
 0389  F6 F3			    div     bl                     ; AL = Quociente, AH = Resto

				    ; AH contém o resto da divisão
 038B  8A CC			    mov     cl, ah                 ; Move o resto para CL
 038D  32 E4			    xor     ah, ah                 ; Limpa AH para evitar resíduos


				    ; Imprime o valor do resto (divisão do checksum por 11)
 038F  50			    push    ax                     ; Salva AX antes da exibição
 0390  8B C1			    mov     ax, cx                 ; Move o valor do resto para AX
 0392  A3 1F92 R			mov 	Checksum, ax
 0395  E8 00A2			    call    print_number           ; Imprime o valor do checksum dividido por 11
 0398  8D 1E 1F95 R		    lea     bx, MsgNewLine         ; Prepara nova linha
 039C  E8 008A			    call    printf_s
 039F  58			    pop     ax                     ; Restaura AX

				    ; Restaura registradores
 03A0  5A			    pop     dx
 03A1  59			    pop     cx
 03A2  5B			    pop     bx
 03A3  58			    pop     ax

				    ; Continua para a próxima etapa
 03A4  EB 45			    jmp     termina_calculo_checksum

 03A6				erro_tamanho_invalido:
 03A6  58				pop 	ax
 03A7  5E				pop		si
 03A8  5F				pop 	di 
 03A9  5B				pop 	bx
 03AA  59				pop 	cx

 03AB				erro_tamanho_invalido_loop:

 03AB  C7 04 0000			mov 	[si], 0
 03AF  4E				dec 	si

 03B0  80 3C 0A				cmp 	byte ptr [si], 10
 03B3  75 F6				jne 	erro_tamanho_invalido_loop

 03B5  46				inc 	si
 03B6  57				push 	di
 03B7  8D 3E 218A R			lea 	di, MsgTamanhoInvalido
 03BB  E8 004F				call 	coloca_erro_no_buffer
 03BE  5F				pop 	di

 03BF  4E				dec 	si
 03C0  EB 4A				jmp 	return_transformacao


 03C2				erro_linha_vazia:

 03C2  58				pop     ax
 03C3  5E			    pop     si
 03C4  5F			    pop     di
 03C5  5B			    pop     bx
 03C6  59			    pop     cx
 03C7				erro_linha_vazia_fim:
 03C7  83 EE 08				sub 	si, 8 ; Apagar o SS inicial que sempre é colocado, independentemente se checksum é 0 ou não.

 03CA  57				push 	di
 03CB  8D 3E 214A R			lea 	di, MsgLinhaEmBranco
 03CF  E8 003B				call 	coloca_erro_no_buffer
 03D2  5F				pop 	di

 03D3  4E				dec 	si
 03D4  EB 36				jmp 	return_transformacao

 03D6				erro_caracter_invalido:
 03D6  46				inc 	si
 03D7  57				push 	di
 03D8  8D 3E 2102 R			lea 	di, MsgErrorCaracterInvalido
 03DC  E8 002E				call 	coloca_erro_no_buffer
 03DF  5F				pop 	di

 03E0  4E				dec 	si
 03E1				loop_avanca_ate_acabar_palavra_incorreta:

 03E1  8A 17				mov 	dl, [bx]
 03E3  43				inc 	bx

 03E4  80 FA 0A				cmp 	byte ptr dl, 10
 03E7  75 F8				jne 	loop_avanca_ate_acabar_palavra_incorreta

					;mov 	dl, [bx]
					;cmp 	byte ptr dl, 13
					;je 	incrementa_bx_acaba_palavra

 03E9  EB 21				jmp 	return_transformacao
				;incrementa_bx_acaba_palavra:
					;inc 	bx

					;jmp 	return_transformacao

 03EB				termina_calculo_checksum:
				    ; Restaura registradores salvos e retorna
 03EB  58				pop     ax
 03EC  5E			    pop     si
 03ED  5F			    pop     di
 03EE  5B			    pop     bx
 03EF  59			    pop     cx

 03F0  C6 06 1F94 R 00			mov 	ColocaSeparador, 0
 03F5  8B 0E 1F92 R			mov 	cx, Checksum
 03F9  E8 FECB				call 	transforma_em_barcode_exec

 03FC				coloca_SS_terminar:
 03FC  C6 06 1F94 R 01			mov 	ColocaSeparador, 1

 0401  C7 04 0030			mov 	[si], '0'
 0405  46				inc 	si

 0406  B9 000B				mov     cx, 11
 0409  E8 FEBB				call    transforma_em_barcode_exec

 040C				return_transformacao:
 040C  C3			    ret


 040D				transformaEmBarcode endp

				;--------------------------------------------------------------------
				;Função: Coloca string de erro no buffer do arquivo
				;Entra: (S) -> SI -> aponta para o local do buffer
				;Sai:	(A) -> DI -> aponta para o inicio da string
				;--------------------------------------------------------------------
 040D				coloca_erro_no_buffer 	proc near
 040D				loop_percorre_string:
 040D  8A 15				mov		dl, [di]

 040F  88 14				mov 	[si], dl

 0411  46				inc 	si
 0412  47				inc 	di

 0413  80 FA 00				cmp 	dl, 0
 0416  75 F5				jne 	loop_percorre_string

 0418  C3				ret
 0419				coloca_erro_no_buffer endp


				;--------------------------------------------------------------------
				;Entra: BX -> file handle
				;       dl -> caractere
				;Sai:   AX -> numero de caracteres escritos
				;		CF -> "0" se escrita ok
				;--------------------------------------------------------------------
 0419				setChar	proc	near
 0419  B4 40				mov		ah,40h
 041B  B9 0001				mov		cx,1
 041E  88 16 004D R			mov		FileBuffer,dl
 0422  8D 16 004D R			lea		dx,FileBuffer
 0426  CD 21				int		21h
 0428  C3				ret
 0429				setChar	endp	


				;--------------------------------------------------------------------
				;Função Escrever um string na tela
				;		printf_s(char *s -> BX)
				;--------------------------------------------------------------------
 0429				printf_s	proc	near
 0429  8A 17				mov		dl,[bx]
 042B  80 FA 00				cmp		dl,0
 042E  74 09				je		ps_1

 0430  53				push	bx
 0431  B4 02				mov		ah,2
 0433  CD 21				int		21H
 0435  5B				pop		bx

 0436  43				inc		bx		
 0437  EB F0				jmp		printf_s

 0439				ps_1:
 0439  C3				ret
 043A				printf_s	endp



				;--------------------------------------------------------------------
				; Função para imprimir um número na tela
				; Entrada: AX contém o número a ser impresso
				;--------------------------------------------------------------------
 043A				print_number proc near
 043A  50			    push    ax                    ; Salva AX
 043B  52			    push    dx                    ; Salva DX
 043C  33 C9			    xor     cx, cx                ; Zera CX (contador de dígitos)

				    ; Calcula os dígitos do número (armazenados na pilha)
 043E				print_number_loop:
 043E  33 D2			    xor     dx, dx                ; Zera DX
 0440  F7 36 17BD R		    div     word ptr Divisor10    ; Divide AX por 10 (quociente em AX, resto em DX)
 0444  52			    push    dx                    ; Armazena o dígito na pilha
 0445  41			    inc     cx                    ; Incrementa o contador de dígitos
 0446  85 C0			    test    ax, ax                ; Verifica se o quociente é 0
 0448  75 F4			    jnz     print_number_loop     ; Continua se ainda houver dígitos

				    ; Imprime os dígitos na ordem correta
 044A				print_number_output:
 044A  5A			    pop     dx                    ; Recupera o próximo dígito
 044B  80 C2 30			    add     dl, '0'               ; Converte o dígito para ASCII
 044E  B4 02			    mov     ah, 2                 ; Função para imprimir caractere
 0450  CD 21			    int     21h                   ; Chama a interrupção do DOS
 0452  E2 F6			    loop    print_number_output   ; Continua até imprimir todos os dígitos

 0454  5A			    pop     dx                    ; Restaura DX
 0455  58			    pop     ax                    ; Restaura AX
 0456  C3			    ret
 0457				print_number endp

				;--------------------------------------------------------------------
						end
				;--------------------------------------------------------------------
Microsoft (R) Macro Assembler Version 6.11		    01/07/25 17:44:05
main.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 21DA	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 0457	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

coloca_erro_no_buffer  . . . . .	P Near	 040D	  _TEXT	Length= 000C Private
criaNovoBuffer . . . . . . . . .	P Near	 016B	  _TEXT	Length= 0291 Private
fclose . . . . . . . . . . . . .	P Near	 014F	  _TEXT	Length= 0005 Private
fcreate  . . . . . . . . . . . .	P Near	 0145	  _TEXT	Length= 000A Private
fopen  . . . . . . . . . . . . .	P Near	 013C	  _TEXT	Length= 0009 Private
getChar  . . . . . . . . . . . .	P Near	 0154	  _TEXT	Length= 0017 Private
print_number . . . . . . . . . .	P Near	 043A	  _TEXT	Length= 001D Private
printf_s . . . . . . . . . . . .	P Near	 0429	  _TEXT	Length= 0011 Private
setChar  . . . . . . . . . . . .	P Near	 0419	  _TEXT	Length= 0010 Private
transformaEmBarcode  . . . . . .	P Near	 020E	  _TEXT	Length= 01FF Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
BarCodeTable . . . . . . . . . .	Byte	 1F98	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
ChecksumBuffer . . . . . . . . .	Byte	 17BF	  _DATA	
ChecksumTotal  . . . . . . . . .	Word	 1F90	  _DATA	
Checksum . . . . . . . . . . . .	Word	 1F92	  _DATA	
ColocaSeparador  . . . . . . . .	Byte	 1F94	  _DATA	
ContadorBuffer . . . . . . . . .	Word	 000B	  _DATA	
Divisor10  . . . . . . . . . . .	Word	 17BD	  _DATA	
FileBuffer . . . . . . . . . . .	Byte	 004D	  _DATA	
FileHandleDst  . . . . . . . . .	Word	 004B	  _DATA	
FileHandleSrc  . . . . . . . . .	Word	 0049	  _DATA	
FileNameDst  . . . . . . . . . .	Byte	 0041	  _DATA	
FileNameSrc  . . . . . . . . . .	Byte	 003A	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
MsgErroCreateFile  . . . . . . .	Byte	 1FDA	  _DATA	
MsgErroOpenFile  . . . . . . . .	Byte	 1FA4	  _DATA	
MsgErroReadFile  . . . . . . . .	Byte	 200F	  _DATA	
MsgErroSemStart  . . . . . . . .	Byte	 2045	  _DATA	
MsgErroSemStop . . . . . . . . .	Byte	 207E	  _DATA	
MsgErroWriteFile . . . . . . . .	Byte	 20CD	  _DATA	
MsgErrorCaracterInvalido . . . .	Byte	 2102	  _DATA	
MsgLinhaEmBranco . . . . . . . .	Byte	 214A	  _DATA	
MsgNewLine . . . . . . . . . . .	Byte	 1F95	  _DATA	
MsgTamanhoInvalido . . . . . . .	Byte	 218A	  _DATA	
NewBuffer  . . . . . . . . . . .	Byte	 081D	  _DATA	
NomeArquivoEntrada . . . . . . .	Byte	 000D	  _DATA	
NomeArquivoSaida . . . . . . . .	Byte	 001F	  _DATA	
OutputBuffer . . . . . . . . . .	Byte	 0FED	  _DATA	
PalavraStart . . . . . . . . . .	Byte	 0000	  _DATA	
PalavraStop  . . . . . . . . . .	Byte	 0006	  _DATA	
Pesochecksum . . . . . . . . . .	Byte	 1F8F	  _DATA	
checagem_fim_arquivo . . . . . .	L Near	 00B5	  _TEXT	
checksum_done  . . . . . . . . .	L Near	 0380	  _TEXT	
coloca_SS_terminar . . . . . . .	L Near	 03FC	  _TEXT	
coloca_valor_correto_travessao .	L Near	 0368	  _TEXT	
criaNovoBuffer_end . . . . . . .	L Near	 01EA	  _TEXT	
criaNovoBuffer_insere  . . . . .	L Near	 01B6	  _TEXT	
criaNovoBuffer_loop2 . . . . . .	L Near	 01B3	  _TEXT	
criaNovoBuffer_loop  . . . . . .	L Near	 016F	  _TEXT	
criaNovoBuffer_print . . . . . .	L Near	 01FB	  _TEXT	
criaNovoBuffer_sem_start . . . .	L Near	 01ED	  _TEXT	
criaNovoBuffer_sem_stop  . . . .	L Near	 0203	  _TEXT	
criarArquivoSaida  . . . . . . .	L Near	 0030	  _TEXT	
erro_caracter_invalido . . . . .	L Near	 03D6	  _TEXT	
erro_linha_vazia_fim . . . . . .	L Near	 03C7	  _TEXT	
erro_linha_vazia . . . . . . . .	L Near	 03C2	  _TEXT	
erro_tamanho_invalido_loop . . .	L Near	 03AB	  _TEXT	
erro_tamanho_invalido  . . . . .	L Near	 03A6	  _TEXT	
escreve_cr_lf  . . . . . . . . .	L Near	 00D9	  _TEXT	
final_loop_escrever_output . . .	L Near	 00F6	  _TEXT	
ignora_caractere . . . . . . . .	L Near	 0374	  _TEXT	
incrementa_bx_start_2  . . . . .	L Near	 01B0	  _TEXT	
incrementa_bx  . . . . . . . . .	L Near	 00B0	  _TEXT	
incrementa_si  . . . . . . . . .	L Near	 034B	  _TEXT	
leituraCorretaArquivoEntrada . .	L Near	 0073	  _TEXT	
lerArquivoDeEntrada  . . . . . .	L Near	 0050	  _TEXT	
loop_acha_primeiro . . . . . . .	L Near	 02D1	  _TEXT	
loop_avanca_ate_acabar_palavra_incorreta . L Near   03E1     _TEXT	
loop_calcula_checksum  . . . . .	L Near	 0352	  _TEXT	
loop_coloca_valores_acaba_final 	L Near	 0305	  _TEXT	
loop_coloca_valores_acaba  . . .	L Near	 02E9	  _TEXT	
loop_coloca_valores  . . . . . .	L Near	 02D7	  _TEXT	
loop_conta_palavras_checksum . .	L Near	 031C	  _TEXT	
loop_conta_palavras_end  . . . .	L Near	 032B	  _TEXT	
loop_escreve_START_arquivo_saida .	L Near	 00C5	  _TEXT	
loop_escreve_start . . . . . . .	L Near	 00CA	  _TEXT	
loop_escreve_stop  . . . . . . .	L Near	 00FE	  _TEXT	
loop_escrever_STOP . . . . . . .	L Near	 00F9	  _TEXT	
loop_escrever_output_fim . . . .	L Near	 010D	  _TEXT	
loop_escrever_output . . . . . .	L Near	 00EA	  _TEXT	
loop_percorre_string . . . . . .	L Near	 040D	  _TEXT	
loop_transformacoes  . . . . . .	L Near	 009A	  _TEXT	
loop_volta_inicio_linha  . . . .	L Near	 029E	  _TEXT	
nao_eh_travessao . . . . . . . .	L Near	 036A	  _TEXT	
print_number_loop  . . . . . . .	L Near	 043E	  _TEXT	
print_number_output  . . . . . .	L Near	 044A	  _TEXT	
ps_1 . . . . . . . . . . . . . .	L Near	 0439	  _TEXT	
pula_coloca_zero . . . . . . . .	L Near	 0303	  _TEXT	
return_transformacao . . . . . .	L Near	 040C	  _TEXT	
termina_calculo_checksum . . . .	L Near	 03EB	  _TEXT	
terminouLerArquivoEntrada  . . .	L Near	 007A	  _TEXT	
transformaEmBarcode_codigo . . .	L Near	 02C1	  _TEXT	
transformaEmBarcode_erro_caractere_invalido  L Near   029E     _TEXT	
transformaEmBarcode_fim_traducao .	L Near	 0306	  _TEXT	
transformaEmBarcode_loop . . . .	L Near	 0226	  _TEXT	
transforma_em_barcode_exec . . .	L Near	 02C7	  _TEXT	
zerar_checksum . . . . . . . . .	L Near	 034C	  _TEXT	

	   0 Warnings
	   0 Errors
