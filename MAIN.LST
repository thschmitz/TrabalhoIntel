Microsoft (R) Macro Assembler Version 6.11		    12/29/24 13:56:58
main.asm						     Page 1 - 1


				
				;
				;====================================================================
				;	- Escrever um programa para ler um arquivo texto e 
				;		apresentá-lo na tela
				;	- O usuário devem informar o nome do arquivo, 
				;		assim que for apresentada a mensagem: Nome do arquivo: 
				;====================================================================
				;
					.model		small
					.stack
						
 = 000D				CR		equ		0dh
 = 000A				LF		equ		0ah
				
 0000					.data
				
 0000 0000			ContadorBuffer  dw 	0
 0002 54 65 73 74 65 00		NomeTesteAleatorio db 	"Teste", 0
 0008 49 4E 2E 74 78 74		FileNameSrc		db		"IN.txt", 0		; Nome do arquivo a ser lido
       00
 000F 4F 55 54 2E 74 78		FileNameDst		db		"OUT.txt", 0	; Nome do arquivo a ser escrito
       74 00
 0017 0000			FileHandleSrc	dw		0				; Handler do arquivo origem
 0019 0000			FileHandleDst	dw		0				; Handler do arquivo destino
 001B  07D0 [			FileBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 07EB  07D0 [			NewBuffer		db		2000 dup (?)	; Buffer de leitura/escrita do arquivo
        00
       ]
 0FBB  07D0 [			OutputBuffer    db 		2000 dup(?) 	; Espaço para os BarCodes (64 bytes)
        00
       ]
				
				
 178B 000A			Divisor10 		dw 		10
 178D  07D0 [			ChecksumBuffer 	db 		2000 dup(?) 	; Espaço para os Checksums (64 bytes)
        00
       ]
 1F5D 00			Pesochecksum 	db		0
 1F5E 0000			ChecksumTotal   dw 		0
 1F60 0000			Checksum 		dw		0
 1F62 01			ColocaSeparador	db		1
 1F63 0D 0A 00			MsgNewLine          db CR, LF, 0 ; Caractere para nova linha
				
 1F66 2B			BarCodeTable DB 101011b     ; 0
 1F67  6B				DB 1101011b    ; 1
 1F68  4B				DB 1001011b    ; 2
 1F69  65				DB 1100101b    ; 3
 1F6A  5B				DB 1011011b    ; 4
 1F6B  6D				DB 1101101b    ; 5
 1F6C  4D				DB 1001101b    ; 6
 1F6D  53				DB 1010011b    ; 7
 1F6E  69				DB 1101001b    ; 8
 1F6F  6D				DB 1101101b    ; 9
 1F70  2D				DB 101101b     ; -
 1F71  59				DB 1011001b    ; SS
				
				
				
 1F72 45 72 72 6F 3A 20		MsgErroOpenFile		db	"Erro: Nao foi possivel fazer a abertura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 61 62 65 72 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 1FA8 45 72 72 6F 3A 20		MsgErroCreateFile	db	"Erro: Nao foi possivel fazer a criacao do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 63 72 69 61 63
       61 6F 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 1FDD 45 72 72 6F 3A 20		MsgErroReadFile		db	"Erro: Nao foi possível fazer a leitura do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       C3 AD 76 65 6C 20
       66 61 7A 65 72 20
       61 20 6C 65 69 74
       75 72 61 20 64 6F
       20 61 72 71 75 69
       76 6F 2E 0D 0A 00
 2013 45 72 72 6F 3A 20		MsgErroSemStart		db	"Erro: Nao foi encontrado a palavra 'START' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 41 52 54 27
       20 6E 6F 20 61 72
       71 75 69 76 6F 2E
       0D 0A 00
 204C 45 72 72 6F 3A 20		MsgErroSemStop		db	"Erro: Nao foi encontrado a palavra 'STOP' no arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 65 6E 63 6F
       6E 74 72 61 64 6F
       20 61 20 70 61 6C
       61 76 72 61 20 27
       53 54 4F 50 27 20
       6E 6F 20 61 72 71
       75 69 76 6F 2E 0D
       0A 00
 2084 45 72 72 6F 3A 20		MsgErroWriteFile	db	"Erro: Nao foi possivel fazer a escrita do arquivo.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 65 73 63 72 69
       74 61 20 64 6F 20
       61 72 71 75 69 76
       6F 2E 0D 0A 00
 20B9 45 72 72 6F 3A 20		MsgErrorCaracterInvalido db "Erro: Nao foi possivel fazer a traducao de um caracter que eh invalido.", CR, LF, 0
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 74 72 61 64 75
       63 61 6F 20 64 65
       20 75 6D 20 63 61
       72 61 63 74 65 72
       20 71 75 65 20 65
       68 20 69 6E 76 61
       6C 69 64 6F 2E 0D
       0A 00
 2103 45 72 72 6F 3A 20		MsgLinhaEmBranco	db 	"Erro: Nao foi possivel fazer a transcricao de uma linha em branco."
       4E 61 6F 20 66 6F
       69 20 70 6F 73 73
       69 76 65 6C 20 66
       61 7A 65 72 20 61
       20 74 72 61 6E 73
       63 72 69 63 61 6F
       20 64 65 20 75 6D
       61 20 6C 69 6E 68
       61 20 65 6D 20 62
       72 61 6E 63 6F 2E
				
 0000					.code
					.startup
				
 0017  8D 16 0008 R			lea		dx,FileNameSrc
 001B  E8 00A8				call	fopen
 001E  89 1E 0017 R			mov		FileHandleSrc,bx
 0022  73 0C				jnc		Continua1
 0024  8D 1E 1F72 R			lea		bx, MsgErroOpenFile
 0028  E8 0342				call	printf_s
					.exit	1
 0030				Continua1:
				
 0030  8D 16 000F R			lea		dx,FileNameDst
 0034  E8 0098				call	fcreate
 0037  89 1E 0019 R			mov		FileHandleDst,bx
 003B  73 13				jnc		Continua2
 003D  8B 1E 0017 R			mov		bx,FileHandleSrc
 0041  E8 0095				call	fclose
 0044  8D 1E 1FA8 R			lea		bx, MsgErroCreateFile
 0048  E8 0322				call	printf_s
					.exit	1
 0050				Continua2:
				
 0050  8B 1E 0017 R			mov		bx,FileHandleSrc    
 0054  E8 0087				call	getChar
 0057  73 1A				jnc		Continua3
 0059  8D 1E 1FDD R			lea		bx, MsgErroReadFile
 005D  E8 030D				call	printf_s
 0060  8B 1E 0017 R			mov		bx,FileHandleSrc
 0064  E8 0072				call	fclose
 0067  8B 1E 0019 R			mov		bx,FileHandleDst
 006B  E8 006B				call	fclose
					.exit	1
 0073				Continua3:
				
 0073  83 F8 00				cmp		ax,0
 0076  74 02				jz		TerminouArquivo
 0078  EB D6				jmp 	Continua2
					
 007A				TerminouArquivo:
 007A  E8 0078				call    criaNovoBuffer
				
 007D  8D 36 0FBB R			lea 	si, OutputBuffer
 0081  8D 1E 07EB R			lea 	bx, NewBuffer
 0085				loop_transformacoes:
 0085  E8 00FF				call    transformaEmBarcode
 0088  C7 04 000A			mov 	[si], 10
 008C  46				inc 	si
 008D  80 3F 00				cmp 	byte ptr [bx], 0
 0090  75 F3				jne 	loop_transformacoes
				
				
				
				
				
				
				
				
				
				
				
				
 0092  8D 36 0FBB R			lea 	si, OutputBuffer
 0096  8B 1E 0019 R			mov 	bx, FileHandleDst
 009A  B9 0000				mov 	cx, 0
 009D				loop_escrever_output:
 009D  8A 14				mov 	dl, [si]
 009F  80 FA 00				cmp 	byte ptr dl, 0
 00A2  74 08				je 		loop_escrever_output_fim
 00A4  53				push 	bx
 00A5  E8 02B5				call 	setChar
 00A8  5B				pop 	bx
 00A9  46				inc 	si
 00AA  EB F1				jmp 	loop_escrever_output
					
 00AC				loop_escrever_output_fim:
 00AC  8D 1E 0FBB R			lea 	bx, OutputBuffer
 00B0  E8 02BA				call 	printf_s
				
				
				
				
				
				
				
				
				
				
				
				
 00B3  8B 1E 0017 R			mov		bx,FileHandleSrc	; Fecha arquivo origem
 00B7  E8 001F				call	fclose
 00BA  8B 1E 0019 R			mov		bx,FileHandleDst	; Fecha arquivo destino
 00BE  E8 0018				call	fclose
					.exit	0
				
				
				;--------------------------------------------------------------------
				;Função	Abre o arquivo cujo nome está no string apontado por DX
				;		boolean fopen(char *FileName -> DX)
				;Entra: DX -> ponteiro para o string com o nome do arquivo
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00C6				fopen	proc	near
 00C6  B0 00				mov		al,0
 00C8  B4 3D				mov		ah,3dh
 00CA  CD 21				int		21h
 00CC  8B D8				mov		bx,ax
 00CE  C3				ret
 00CF				fopen	endp
				
				;--------------------------------------------------------------------
				;Função Cria o arquivo cujo nome está no string apontado por DX
				;		boolean fcreate(char *FileName -> DX)
				;Sai:   BX -> handle do arquivo
				;       CF -> 0, se OK
				;--------------------------------------------------------------------
 00CF				fcreate	proc	near
 00CF  B9 0000				mov		cx,0
 00D2  B4 3C				mov		ah,3ch
 00D4  CD 21	int		21h
 00D6  8B D8				mov		bx,ax
 00D8  C3				ret
 00D9				fcreate	endp
				
				;--------------------------------------------------------------------
				;Entra:	BX -> file handle
				;Sai:	CF -> "0" se OK
				;--------------------------------------------------------------------
 00D9				fclose	proc	near
 00D9  B4 3E				mov		ah,3eh
 00DB  CD 21				int		21h
 00DD  C3				ret
 00DE				fclose	endp
				
				;--------------------------------------------------------------------
				;Função	Le um caractere do arquivo identificado pelo HANLDE BX
				;		getChar(handle->BX)
				;Entra: BX -> file handle
				;Sai:   
				;		AX -> numero de caracteres lidos
				;		CF -> "0" se leitura ok
				;--------------------------------------------------------------------
 00DE				getChar proc near
 00DE  B9 0001			    mov     cx, 1                  ; Number of bytes to read
 00E1  8D 36 001B R		    lea     si, FileBuffer         ; Load the base address of FileBuffer into SI
 00E5  8B D6			    mov     dx, si                 ; Copy base address to DX (used by DOS)
 00E7  A1 0000 R		    mov     ax, ContadorBuffer     ; Load FileCounter into AX
 00EA  03 D0			    add     dx, ax                 ; Adjust DX to point to the current position
 00EC  B4 3F			    mov     ah, 3Fh                ; DOS function: Read from file
 00EE  CD 21			    int     21h                    ; Call DOS interrupt
 00F0  FF 06 0000 R		    inc     ContadorBuffer         ; Increment the counter for the next read
 00F4  C3			    ret                            ; Return to the caller
 00F5				getChar endp
				
				;--------------------------------------------------------------------
				;Função que cria um novo buffer com o conteudo do arquivo que interessa
				;		
				;Sai:   
				;		NovoBuffer -> buffer com o conteudo do arquivo
				;--------------------------------------------------------------------
 00F5				criaNovoBuffer    proc near
 00F5  8D 1E 001B R			lea bx, FileBuffer
				
 00F9				criaNovoBuffer_loop:
 00F9  8A 17				mov 	dl, [bx]	; Carrega o primeiro caractere do buffer
					
 00FB  80 FA 00				cmp 	dl, 0		; Verifica se o buffer está vazio
 00FE  74 66				je 		criaNovoBuffer_sem_start	; Se estiver, retorna
				
 0100  80 FA 53				cmp     byte ptr dl, 'S'             ; Verifica se o caractere é 'S'
 0103  75 5E				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 0105  8A 57 01				mov dl, [bx + 1]
				
 0108  80 FA 54				cmp     byte ptr dl, 'T'  ; Verifica se o próximo caractere é 'T'
 010B  75 56				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 010D  8A 57 02				mov dl, [bx + 2]
				
 0110  80 FA 41				cmp     byte ptr dl, 'A'; Verifica se o próximo caractere é 'A'
 0113  75 4E				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 0115  8A 57 03				mov dl, [bx + 3]
				
 0118  80 FA 52				cmp     byte ptr dl, 'R'; Verifica se o próximo caractere é 'R'
 011B  75 46				jne     criaNovoBuffer_end    ; Se não for, sai do loop
				
 011D  8A 57 04				mov dl, [bx + 4]
				
 0120  80 FA 54				cmp     byte ptr dl, 'T'; Verifica se o próximo caractere é 'T'
 0123  75 3E				jne     criaNovoBuffer_end    ; Se não for, sai do loop
 0125  83 C3 04				add     bx, 4
 0128  8D 36 07EB R			lea 	si, NewBuffer
				
 012C				criaNovoBuffer_loop2:
 012C  43				inc bx
 012D  8A 17				mov 	dl, [bx]
					;cmp     byte ptr dl, 0Ah ; CR (Carriage Return)
					;je criaNovoBuffer_loop2
					;cmp     byte ptr dl, 0Dh ; LF (Line Feed)
					;je criaNovoBuffer_loop2
				
					;dec bx
 012F				criaNovoBuffer_insere:
 012F  03 C6				add     ax, si
 0131  43				inc 	bx
 0132  8A 17				mov 	dl, [bx]
 0134  80 FA 00				cmp     byte ptr dl, 0 
 0137  74 43				je		criaNovoBuffer_sem_stop
				
 0139  88 14				mov 	byte ptr [si], dl
 013B  46				inc 	si
				
 013C  80 FA 53				cmp 	byte ptr dl, 'S' ; Verifica se o próximo caractere é 'S' de 'STOP'
 013F  75 EE				jne		criaNovoBuffer_insere
 0141  4E				dec si 
				
 0142  8A 57 01				mov 	dl, [bx + 1]
 0145  80 FA 54				cmp 	byte ptr dl, 'T' ; Verifica se o próximo caractere é 'T' de 'STOP'
 0148  75 E5				jne		criaNovoBuffer_insere
 014A  8A 57 02				mov 	dl, [bx + 2]
 014D  80 FA 4F				cmp 	byte ptr dl, 'O' ; Verifica se o próximo caractere é 'O' de 'STOP'
 0150  75 DD				jne		criaNovoBuffer_insere
 0152  8A 57 03				mov 	dl, [bx + 3]
 0155  80 FA 50				cmp 	byte ptr dl, 'P' ; Verifica se o próximo caractere é 'P' de 'STOP'
 0158  75 D5				jne		criaNovoBuffer_insere
 015A  83 C3 04				add 	bx, 4
				
 015D  C7 04 0000			mov     [si], 0
					
 0161  EB 11				jmp     criaNovoBuffer_print
					
 0163				criaNovoBuffer_end:
 0163  43				inc bx
 0164  EB 93				jmp criaNovoBuffer_loop
				
 0166				criaNovoBuffer_sem_start:
 0166  83 F9 00				cmp cx, 0
 0169  8D 1E 2013 R			lea bx, MsgErroSemStart
 016D  E8 01FD				call printf_s
					.exit
				
 0174				criaNovoBuffer_print:
 0174  8D 1E 07EB R			lea bx, NewBuffer
				
 0178  E8 01F2				call printf_s
 017B  C3				ret
				
 017C				criaNovoBuffer_sem_stop:
 017C  8D 1E 204C R			lea bx, MsgErroSemStop
 0180  E8 01EA				call printf_s
					.exit
				
 0187				criaNovoBuffer    endp
				
				;--------------------------------------------------------------------
				;Função que traduz cada caracter do novo buffer em um barcode 
				;		
				;Sai:   
				;		Buffer com dados em barcode
				;--------------------------------------------------------------------
 0187				transformaEmBarcode proc near
 0187  B9 0000				mov     cx, 0
				
					
 018A  B9 000B				mov      cx, 11
 018D  E8 0096				call     transforma_em_barcode_exec
				
 0190  8C DA				mov 	dx, ds
 0192  8E C2				mov 	es, dx
 0194  BF 0000				mov 	di, 0
 0197  8D 3E 178D R			lea 	di, ChecksumBuffer
 019B  33 C0			    xor     ax, ax                ; Zera AX para evitar resíduos
				
 019D				transformaEmBarcode_loop:
 019D  8A 17				mov     dl, [bx]
 019F  88 15				mov 	[di], dl
 01A1  43				inc bx
 01A2  47				inc di
				
 01A3  80 FA 00				cmp     byte ptr dl, 0    ; Verifica se o buffer está vazio
 01A6  75 03 E9 00C4			je      transformaEmBarcode_fim_traducao    ; Se estiver, retorna
				
 01AB  80 FA 0D				cmp 	byte ptr dl, 13
 01AE  75 03 E9 00BC			je 		transformaEmBarcode_fim_traducao
				
 01B3  80 FA 0A				cmp 	byte ptr dl, 10
 01B6  75 03 E9 00B4			je 		transformaEmBarcode_fim_traducao
				
 01BB  B9 0000				mov 	cx, 0
 01BE  80 FA 30				cmp     byte ptr dl, '0'    ; Verifica se o caractere é '0'
 01C1  74 5D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01C3  B9 0001				mov 	cx, 1
 01C6  80 FA 31				cmp     byte ptr dl, '1'    ; Verifica se o caractere é '1'
 01C9  74 55				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01CB  B9 0002				mov 	cx, 2
 01CE  80 FA 32				cmp     byte ptr dl, '2'    ; Verifica se o caractere é '2'
 01D1  74 4D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01D3  B9 0003				mov 	cx, 3
 01D6  80 FA 33				cmp     byte ptr dl, '3'    ; Verifica se o caractere é '3'
 01D9  74 45				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01DB  B9 0004				mov 	cx, 4
 01DE  80 FA 34				cmp     byte ptr dl, '4'    ; Verifica se o caractere é '4'
 01E1  74 3D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01E3  B9 0005				mov 	cx, 5
 01E6  80 FA 35				cmp     byte ptr dl, '5'    ; Verifica se o caractere é '5'
 01E9  74 35				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01EB  B9 0006				mov 	cx, 6
 01EE  80 FA 36				cmp     byte ptr dl, '6'    ; Verifica se o caractere é '6'
 01F1  74 2D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01F3  B9 0007				mov 	cx, 7
 01F6  80 FA 37				cmp     byte ptr dl, '7'    ; Verifica se o caractere é '7'
 01F9  74 25				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 01FB  B9 0008				mov 	cx, 8
 01FE  80 FA 38				cmp     byte ptr dl, '8'    ; Verifica se o caractere é '8'
 0201  74 1D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 0203  B9 0009				mov 	cx, 9
 0206  80 FA 39				cmp     byte ptr dl, '9'    ; Verifica se o caractere é '9'
 0209  74 15				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 020B  B9 000A				mov 	cx, 10
 020E  80 FA 2D				cmp     byte ptr dl, '-'    ; Verifica se o caractere é '-'
 0211  74 0D				je      transformaEmBarcode_codigo    ; Se for, pula para a função que transforma em barcode
				
 0213  EB 00				jmp     transformaEmBarcode_erro_caractere_invalido
				
 0215				transformaEmBarcode_erro_caractere_invalido:
 0215  8D 1E 20B9 R			lea     bx, MsgErrorCaracterInvalido
 0219  E8 0151				call    printf_s
					.exit
				
 0220				transformaEmBarcode_codigo:
 0220  E8 0003				call transforma_em_barcode_exec
 0223  E9 FF77				jmp transformaEmBarcode_loop
				
 0226				transforma_em_barcode_exec:
 0226  53				push 	bx
 0227  8D 1E 1F66 R			lea 	bx, BarCodeTable
 022B  03 D9				add 	bx, cx
 022D  8A 17				mov 	dl, [bx]
 022F  5B				pop bx
 0230				loop_acha_primeiro_0:
 0230  D0 E2				shl	 dl, 1
 0232  72 02				jc loop_coloca_valores_0
 0234  EB FA				jmp loop_acha_primeiro_0
				
 0236				loop_coloca_valores_0:
 0236  B8 0030				mov  ax, 30h
 0239  83 D0 00				adc  ax, 0
				
 023C  89 04				mov	 [si], ax
 023E  46				inc si
				
 023F  80 FA 00				cmp 	dl, 0
 0242  74 04				je  	loop_coloca_valores_0_acaba
				
 0244  D0 E2				shl 	dl, 1
 0246  EB EE				jmp 	loop_coloca_valores_0
				
 0248				loop_coloca_valores_0_acaba:
					
 0248  83 F9 0A				cmp 	cx, 10
 024B  7F 21				jg 		loop_coloca_valores_0_acaba_final
 024D  53				push bx
 024E  52				push dx
 024F  8A 17				mov 	dl, [bx]
				
 0251  80 3E 1F62 R 00			cmp 	ColocaSeparador, 0
 0256  74 14				je  	pula_coloca_zero
					
 0258  80 FA 00				cmp     byte ptr dl, 0    ; Verifica se o buffer está vazio
 025B  74 0F				je      pula_coloca_zero    ; Se estiver, retorna
				
 025D  80 FA 0D				cmp 	byte ptr dl, 13
 0260  74 0A				je 		pula_coloca_zero
				
 0262  80 FA 0A				cmp 	byte ptr dl, 10
 0265  74 05				je 		pula_coloca_zero
					
 0267  C7 04 0030			mov 	[si], '0'
 026B  46				inc 	si
 026C				pula_coloca_zero:
 026C  5A				pop dx
 026D  5B				pop bx
					
 026E				loop_coloca_valores_0_acaba_final:
 026E  C3				ret
				
 026F				transformaEmBarcode_fim_traducao:
 026F  C6 05 00			    mov     byte ptr [di], 0      ; Adiciona terminador null no final do ChecksumBuffer
 0272  51			    push    cx                    ; Salva CX
 0273  53			    push    bx
 0274  57			    push    di
 0275  56			    push    si
 0276  50			    push    ax
				
				    ; Calcula o comprimento da palavra
 0277  B1 00			    mov     cl, 0                 ; Zera CL (contador de caracteres)
 0279  8D 3E 178D R		    lea     di, ChecksumBuffer    ; Ponteiro para o início do buffer
 027D				loop_conta_palavras_checksum:
 027D  80 3D 0A			    cmp     byte ptr [di], 0AH      ; Verifica o final da palavra
 0280  74 05			    je      loop_conta_palavras_end
 0282  47			    inc     di                    ; Avança para o próximo caractere
 0283  FE C1			    inc     cl                    ; Incrementa o comprimento
 0285  EB F6			    jmp     loop_conta_palavras_checksum
				
 0287loop_conta_palavras_end:
 0287  88 0E 1F5D R		    mov     Pesochecksum, cl      ; Define o peso inicial como o comprimento da palavra
				
 028B  8D 36 178D R		    lea     si, ChecksumBuffer    ; Ponteiro para o início do buffer
 028F  80 3E 1F5D R 00		    cmp     Pesochecksum, 0
 0294  74 63			    jz      erro_linha_em_branco
				
 0296  C7 06 1F5E R 0000	    mov     ChecksumTotal, 0      ; Zera o ChecksumTotal
 029C				loop_calcula_checksum:
 029C  8A 04			    mov     al, [si]              ; Carrega o próximo byte do ChecksumBuffer em AL
 029E  3C 00			    cmp     al, 0                 ; Verifica se chegou ao final do buffer
 02A0  74 28			    je      checksum_done
				
				    ; Ignora caracteres indesejados (CR e LF)
 02A2  3C 0D			    cmp     al, 0Dh               ; CR
 02A4  74 18			    je      ignora_caractere
 02A6  3C 0A			    cmp     al, 0Ah               ; LF
 02A8  74 14			    je      ignora_caractere
				
				    ; Verifica se é numérico
 02AA  3C 30			    cmp     al, '0'
 02AC  72 10			    jb      ignora_caractere
 02AE  3C 39			    cmp     al, '9'
 02B0  77 0C			    ja      ignora_caractere
				
				    ; Converte o caractere numérico de ASCII para número
 02B2  2C 30			    sub     al, '0'               ; Converte de ASCII para número
 02B4  B4 00			    mov     ah, 0                 ; Garante que AH está zerado
 02B6  F6 26 1F5D R		    mul     Pesochecksum          ; Multiplica pelo peso
				
				    ; Soma ao total do checksum
 02BA  01 06 1F5E R		    add     ChecksumTotal, ax
				
				    ; Diagnóstico: imprime o caractere processado
				    ;mov     dl, [si]
				    ;mov     ah, 2                 ; Interrupção do DOS para imprimir caractere
				    ;int     21h
				    ;lea     bx, MsgNewLine
				    ;call    printf_s
				
 02BE				ignora_caractere:
				    ; Ignora o caractere e avança no buffer
 02BE  46			    inc     si                    ; Avança para o próximo caractere
 02BF  FE 0E 1F5D R		    dec     Pesochecksum          ; Reduz o peso
 02C3  80 3E 1F5D R 00		    cmp     Pesochecksum, 0
 02C8  75 D2			    jnz     loop_calcula_checksum
				
 02CA				checksum_done:
				    ; Salva registradores na pilha
 02CA  50			    push    ax
 02CB  53			    push    bx
 02CC  51			    push    cx
 02CD  52			    push    dx
				
				    ; Calcula o resto da divisão do ChecksumTotal por 11
 02CE  A1 1F5E R		    mov     ax, ChecksumTotal      ; Carrega o ChecksumTotal em AX
 02D1  B3 0B			    mov     bl, 11                 ; Define o divisor como 11
 02D3  F6 F3			    div     bl                     ; AL = Quociente, AH = Resto
				
				    ; AH contém o resto da divisão
 02D5  8A CC			    mov     cl, ah                 ; Move o resto para CL
 02D7  32 E4			    xor     ah, ah                 ; Limpa AH para evitar resíduos
				
				
				    ; Imprime o valor do resto (divisão do checksum por 11)
 02D9  50			    push    ax                     ; Salva AX antes da exibição
 02DA  8B C1			    mov     ax, cx                 ; Move o valor do resto para AX
 02DC  A3 1F60 R			mov 	Checksum, ax
 02DF  E8 005E			    call    print_number           ; Imprime o valor do checksum dividido por 11
 02E2  8D 1E 1F63 R		    lea     bx, MsgNewLine         ; Prepara nova linha
 02E6  E8 0084			    call    printf_s
 02E9  58			    pop     ax                     ; Restaura AX
				
				    ; Restaura registradores
 02EA  5A			    pop     dx
 02EB  59			    pop     cx
 02EC  5B			    pop     bx
 02ED  58			    pop     ax
				
				    ; Continua para a próxima etapa
 02EE  EB 19			    jmp     termina_calculo_checksum
				
 02F0				erro_caractere_invalido:
				    ; Mensagem de erro para caracteres inválidos
 02F0  8D 1E 20B9 R		    lea     bx, MsgErrorCaracterInvalido
 02F4  E8 0076			    call    printf_s
 02F7  EB 10			    jmp     termina_calculo_checksum
				
 02F9				erro_linha_em_branco:
				    ; Mensagem de erro para linha em branco
 02F9  8D 1E 2103 R		    lea     bx, MsgLinhaEmBranco
 02FD  E8 006D			    call    printf_s
 0300  8D 1E 1F63 R			lea 	bx, MsgNewLine
 0304  E8 0066				call    printf_s
 0307  EB 00				jmp     termina_calculo_checksum
				
 0309				termina_calculo_checksum:
				    ; Restaura registradores salvos e retorna
 0309  58			    pop     ax
 030A  5E			    pop     si
 030B  5F			    pop     di
 030C  5B			    pop     bx
 030D  59			    pop     cx
					
 030E  C6 06 1F62 R 00			mov 	ColocaSeparador, 0
 0313  8B 0E 1F60 R			mov 	cx, Checksum
 0317  E8 FF0C				call transforma_em_barcode_exec
 031A  C6 06 1F62 R 01			mov 	ColocaSeparador, 1
 031F  B9 000B				mov      cx, 11
 0322  E8 FF01				call     transforma_em_barcode_exec
 0325  C3			    ret
				
				
 0326				transformaEmBarcode endp
				
				
				;
				;--------------------------------------------------------------------
				;Função:Converte um ASCII-DECIMAL para HEXA
				;Entra: (S) -> DS:BX -> Ponteiro para o string de origem
				;Sai:	(A) -> AX -> Valor "Hex" resultante
				;Algoritmo:
				;	A = 0;
				;	while (*S!='\0') {
				;		A = 10 * A + (*S - '0')
				;		++S;
				;	}
				;	return
				;--------------------------------------------------------------------
 0326				atoi	proc near
				
						; A = 0;
 0326  B8 0000					mov		ax,0
						
 0329				atoi_2:
						; while (*S!='\0') {
 0329  80 3F 00					cmp		byte ptr[bx], 0
 032C  74 11					jz		atoi_1
				
						; 	A = 10 * A
 032E  B9 000A					mov		cx,10
 0331  F7 E1					mul		cx
				
						; 	A = A + *S
 0333  B5 00					mov		ch,0
 0335  8A 0F					mov		cl,[bx]
 0337  03 C1					add		ax,cx
				
						; 	A = A - '0'
 0339  83 E8 30					sub		ax,'0'
				
						; 	++S
 033C  43					inc		bx
						
						;}
 033D  EB EA					jmp		atoi_2
				
 033F				atoi_1:
						; return
 033F  C3					ret
				
 0340				atoi	endp
				
				
				;--------------------------------------------------------------------
				; Função para imprimir um número na tela
				; Entrada: AX contém o número a ser impresso
				;--------------------------------------------------------------------
 0340				print_number proc near
 0340  50			    push    ax                    ; Salva AX
 0341  52			    push    dx                    ; Salva DX
 0342  33 C9			    xor     cx, cx                ; Zera CX (contador de dígitos)
				
				    ; Calcula os dígitos do número (armazenados na pilha)
 0344				print_number_loop:
 0344  33 D2			    xor     dx, dx                ; Zera DX
 0346  F7 36 178B R		    div     word ptr Divisor10    ; Divide AX por 10 (quociente em AX, resto em DX)
 034A  52			    push    dx                    ; Armazena o dígito na pilha
 034B  41			    inc     cx                    ; Incrementa o contador de dígitos
 034C  85 C0			    test    ax, ax                ; Verifica se o quociente é 0
 034E  75 F4			    jnz     print_number_loop     ; Continua se ainda houver dígitos
				
				    ; Imprime os dígitos na ordem correta
 0350				print_number_output:
 0350  5A			    pop     dx                    ; Recupera o próximo dígito
 0351  80 C2 30			    add     dl, '0'               ; Converte o dígito para ASCII
 0354  B4 02			    mov     ah, 2                 ; Função para imprimir caractere
 0356  CD 21			    int     21h                   ; Chama a interrupção do DOS
 0358  E2 F6			    loop    print_number_output   ; Continua até imprimir todos os dígitos
				
 035A  5A			    pop     dx                    ; Restaura DX
 035B  58			    pop     ax                    ; Restaura AX
 035C  C3			    ret
 035D				print_number endp
				
				;--------------------------------------------------------------------
				;Entra: BX -> file handle
				;       dl -> caractere
				;Sai:   AX -> numero de caracteres escritos
				;		CF -> "0" se escrita ok
				;--------------------------------------------------------------------
 035D				setChar	proc	near
 035D  B4 40				mov		ah,40h
 035F  B9 0001				mov		cx,1
 0362  88 16 001B R			mov		FileBuffer,dl
 0366  8D 16 001B R			lea		dx,FileBuffer
 036A  CD 21				int		21h
 036C  C3				ret
 036D				setChar	endp	
				
				
				;--------------------------------------------------------------------
				;Função Escrever um string na tela
				;		printf_s(char *s -> BX)
				;--------------------------------------------------------------------
 036D				printf_s	proc	near
 036D  8A 17				mov		dl,[bx]
 036F  80 FA 00				cmp		dl,0
 0372  74 09				je		ps_1
				
 0374  53				push	bx
 0375  B4 02				mov		ah,2
 0377  CD 21				int		21H
 0379  5B				pop		bx
				
 037A  43				inc		bx		
 037B  EB F0				jmp		printf_s
				
 037D				ps_1:
 037D  C3				ret
 037E				printf_s	endp
				
				;--------------------------------------------------------------------
						end
				;--------------------------------------------------------------------
				
				
					
				
				

Microsoft (R) Macro Assembler Version 6.11		    12/29/24 13:56:58
main.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 2145	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 037E	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

atoi . . . . . . . . . . . . . .	P Near	 0326	  _TEXT	Length= 001A Private
criaNovoBuffer . . . . . . . . .	P Near	 00F5	  _TEXT	Length= 0119 Private
fclose . . . . . . . . . . . . .	P Near	 00D9	  _TEXT	Length= 0005 Private
fcreate  . . . . . . . . . . . .	P Near	 00CF	  _TEXT	Length= 000A Private
fopen  . . . . . . . . . . . . .	P Near	 00C6	  _TEXT	Length= 0009 Private
getChar  . . . . . . . . . . . .	P Near	 00DE	  _TEXT	Length= 0017 Private
print_number . . . . . . . . . .	P Near	 0340	  _TEXT	Length= 001D Private
printf_s . . . . . . . . . . . .	P Near	 036D	  _TEXT	Length= 0011 Private
setChar  . . . . . . . . . . . .	P Near	 035D	  _TEXT	Length= 0010 Private
transformaEmBarcode  . . . . . .	P Near	 0187	  _TEXT	Length= 019F Private


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
BarCodeTable . . . . . . . . . .	Byte	 1F66	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
ChecksumBuffer . . . . . . . . .	Byte	 178D	  _DATA	
ChecksumTotal  . . . . . . . . .	Word	 1F5E	  _DATA	
Checksum . . . . . . . . . . . .	Word	 1F60	  _DATA	
ColocaSeparador  . . . . . . . .	Byte	 1F62	  _DATA	
ContadorBuffer . . . . . . . . .	Word	 0000	  _DATA	
Continua1  . . . . . . . . . . .	L Near	 0030	  _TEXT	
Continua2  . . . . . . . . . . .	L Near	 0050	  _TEXT	
Continua3  . . . . . . . . . . .	L Near	 0073	  _TEXT	
Divisor10  . . . . . . . . . . .	Word	 178B	  _DATA	
FileBuffer . . . . . . . . . . .	Byte	 001B	  _DATA	
FileHandleDst  . . . . . . . . .	Word	 0019	  _DATA	
FileHandleSrc  . . . . . . . . .	Word	 0017	  _DATA	
FileNameDst  . . . . . . . . . .	Byte	 000F	  _DATA	
FileNameSrc  . . . . . . . . . .	Byte	 0008	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
MsgErroCreateFile  . . . . . . .	Byte	 1FA8	  _DATA	
MsgErroOpenFile  . . . . . . . .	Byte	 1F72	  _DATA	
MsgErroReadFile  . . . . . . . .	Byte	 1FDD	  _DATA	
MsgErroSemStart  . . . . . . . .	Byte	 2013	  _DATA	
MsgErroSemStop . . . . . . . . .	Byte	 204C	  _DATA	
MsgErroWriteFile . . . . . . . .	Byte	 2084	  _DATA	
MsgErrorCaracterInvalido . . . .	Byte	 20B9	  _DATA	
MsgLinhaEmBranco . . . . . . . .	Byte	 2103	  _DATA	
MsgNewLine . . . . . . . . . . .	Byte	 1F63	  _DATA	
NewBuffer  . . . . . . . . . . .	Byte	 07EB	  _DATA	
NomeTesteAleatorio . . . . . . .	Byte	 0002	  _DATA	
OutputBuffer . . . . . . . . . .	Byte	 0FBB	  _DATA	
Pesochecksum . . . . . . . . . .	Byte	 1F5D	  _DATA	
TerminouArquivo  . . . . . . . .	L Near	 007A	  _TEXT	
atoi_1 . . . . . . . . . . . . .	L Near	 033F	  _TEXT	
atoi_2 . . . . . . . . . . . . .	L Near	 0329	  _TEXT	
checksum_done  . . . . . . . . .	L Near	 02CA	  _TEXT	
criaNovoBuffer_end . . . . . . .	L Near	 0163	  _TEXT	
criaNovoBuffer_insere  . . . . .	L Near	 012F	  _TEXT	
criaNovoBuffer_loop2 . . . . . .	L Near	 012C	  _TEXT	
criaNovoBuffer_loop  . . . . . .	L Near	 00F9	  _TEXT	
criaNovoBuffer_print . . . . . .	L Near	 0174	  _TEXT	
criaNovoBuffer_sem_start . . . .	L Near	 0166	  _TEXT	
criaNovoBuffer_sem_stop  . . . .	L Near	 017C	  _TEXT	
erro_caractere_invalido  . . . .	L Near	 02F0	  _TEXT	
erro_linha_em_branco . . . . . .	L Near	 02F9	  _TEXT	
ignora_caractere . . . . . . . .	L Near	 02BE	  _TEXT	
loop_acha_primeiro_0 . . . . . .	L Near	 0230	  _TEXT	
loop_calcula_checksum  . . . . .	L Near	 029C	  _TEXT	
loop_coloca_valores_0_acaba_final 	L Near	 026E	  _TEXT	
loop_coloca_valores_0_acaba  . .	L Near	 0248	  _TEXT	
loop_coloca_valores_0  . . . . .	L Near	 0236	  _TEXT	
loop_conta_palavras_checksum . .	L Near	 027D	  _TEXT	
loop_conta_palavras_end  . . . .	L Near	 0287	  _TEXT	
loop_escrever_output_fim . . . .	L Near	 00AC	  _TEXT	
loop_escrever_output . . . . . .	L Near	 009D	  _TEXT	
loop_transformacoes  . . . . . .	L Near	 0085	  _TEXT	
print_number_loop  . . . . . . .	L Near	 0344	  _TEXT	
print_number_output  . . . . . .	L Near	 0350	  _TEXT	
ps_1 . . . . . . . . . . . . . .	L Near	 037D	  _TEXT	
pula_coloca_zero . . . . . . . .	L Near	 026C	  _TEXT	
termina_calculo_checksum . . . .	L Near	 0309	  _TEXT	
transformaEmBarcode_codigo . . .	L Near	 0220	  _TEXT	
transformaEmBarcode_erro_caractere_invalido  L Near   0215     _TEXT	
transformaEmBarcode_fim_traducao .	L Near	 026F	  _TEXT	
transformaEmBarcode_loop . . . .	L Near	 019D	  _TEXT	
transforma_em_barcode_exec . . .	L Near	 0226	  _TEXT	

	   0 Warnings
	   0 Errors
